/**
 * TESTE END-TO-END DO SISTEMA DE AGENDAMENTO
 * 
 * Este script testa todo o fluxo do sistema de agendamento:
 * 1. Inicializa√ß√£o dos servi√ßos
 * 2. Detec√ß√£o de inten√ß√£o de agendamento
 * 3. Fluxo de cria√ß√£o de agendamento
 * 4. Integra√ß√£o com Google Calendar
 * 5. Valida√ß√£o de respostas
 * 
 * EXECUTE ESTE TESTE ANTES DE TESTAR O SISTEMA EM PRODU√á√ÉO!
 */

import { LLMOrchestratorService, AppointmentFlowManager, GoogleCalendarService, ClinicContextManager } from './services/core/index.js';
import { createClient } from '@supabase/supabase-js';

// Configura√ß√£o do Supabase
const supabase = createClient(
  process.env.VITE_SUPABASE_URL || 'https://niakqdolcdwxtrkbqmdi.supabase.co',
  process.env.SUPABASE_SERVICE_ROLE_KEY || 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6Im5pYWtxZG9sY2JxbWRpIiwicm9sZSI6InNlcnZpY2Vfcm9sZSIsImlhdCI6MTc1MDE4MjU1OSwiZXhwIjoyMDY1NzU4NTU5fQ.SY8A3ReAs_D7SFBp99PpSe8rpm1hbWMv4b2q-c_VS5M'
);

class AppointmentSystemE2ETest {
  constructor() {
    this.testResults = [];
    this.errors = [];
    this.warnings = [];
  }

  /**
   * Executa todos os testes
   */
  async runAllTests() {
    console.log('üöÄ INICIANDO TESTE END-TO-END DO SISTEMA DE AGENDAMENTO');
    console.log('=' .repeat(80));
    
    try {
      // Teste 1: Verifica√ß√£o de ambiente
      await this.testEnvironment();
      
      // Teste 2: Verifica√ß√£o de banco de dados
      await this.testDatabaseConnection();
      
      // Teste 3: Verifica√ß√£o de cl√≠nicas
      await this.testClinicsAvailability();
      
      // Teste 4: Inicializa√ß√£o dos servi√ßos
      await this.testServicesInitialization();
      
      // Teste 5: Teste de fluxo de agendamento
      await this.testAppointmentFlow();
      
      // Teste 6: Teste de integra√ß√£o com Google Calendar
      await this.testGoogleCalendarIntegration();
      
      // Teste 7: Teste de processamento de mensagens
      await this.testMessageProcessing();
      
      // Teste 8: Valida√ß√£o de respostas
      await this.testResponseValidation();
      
      // Relat√≥rio final
      this.generateFinalReport();
      
    } catch (error) {
      console.error('üí• ERRO CR√çTICO NO TESTE:', error);
      this.errors.push({
        test: 'EXECU√á√ÉO_PRINCIPAL',
        error: error.message,
        stack: error.stack
      });
      this.generateFinalReport();
    }
  }

  /**
   * Teste 1: Verifica√ß√£o de ambiente
   */
  async testEnvironment() {
    console.log('\nüîß TESTE 1: VERIFICA√á√ÉO DE AMBIENTE');
    console.log('-'.repeat(50));
    
    const requiredEnvVars = [
      'VITE_SUPABASE_URL',
      'SUPABASE_SERVICE_ROLE_KEY',
      'OPENAI_API_KEY',
      'WHATSAPP_META_ACCESS_TOKEN',
      'WHATSAPP_META_PHONE_NUMBER_ID'
    ];
    
    const missingVars = [];
    
    for (const envVar of requiredEnvVars) {
      if (!process.env[envVar]) {
        missingVars.push(envVar);
      }
    }
    
    if (missingVars.length > 0) {
      const error = `Vari√°veis de ambiente ausentes: ${missingVars.join(', ')}`;
      console.error(`‚ùå ${error}`);
      this.errors.push({ test: 'ENVIRONMENT', error });
      throw new Error(error);
    }
    
    console.log('‚úÖ Todas as vari√°veis de ambiente est√£o configuradas');
    this.testResults.push({ test: 'ENVIRONMENT', status: 'PASS' });
  }

  /**
   * Teste 2: Verifica√ß√£o de banco de dados
   */
  async testDatabaseConnection() {
    console.log('\nüóÑÔ∏è TESTE 2: VERIFICA√á√ÉO DE BANCO DE DADOS');
    console.log('-'.repeat(50));
    
    try {
      // Testar conex√£o com Supabase
      const { data, error } = await supabase
        .from('clinics')
        .select('count')
        .limit(1);
      
      if (error) {
        throw new Error(`Erro na conex√£o com Supabase: ${error.message}`);
      }
      
      console.log('‚úÖ Conex√£o com Supabase estabelecida com sucesso');
      
      // Verificar tabelas essenciais
      const essentialTables = ['clinics', 'conversations', 'messages', 'conversation_memory'];
      
      for (const table of essentialTables) {
        try {
          const { error: tableError } = await supabase
            .from(table)
            .select('count')
            .limit(1);
          
          if (tableError) {
            this.warnings.push({
              test: 'DATABASE_TABLES',
              warning: `Tabela ${table} n√£o encontrada ou sem acesso`
            });
          } else {
            console.log(`‚úÖ Tabela ${table} acess√≠vel`);
          }
        } catch (tableError) {
          this.warnings.push({
            test: 'DATABASE_TABLES',
            warning: `Erro ao acessar tabela ${table}: ${tableError.message}`
          });
        }
      }
      
      this.testResults.push({ test: 'DATABASE_CONNECTION', status: 'PASS' });
      
    } catch (error) {
      console.error(`‚ùå ${error.message}`);
      this.errors.push({ test: 'DATABASE_CONNECTION', error: error.message });
      throw error;
    }
  }

  /**
   * Teste 3: Verifica√ß√£o de cl√≠nicas
   */
  async testClinicsAvailability() {
    console.log('\nüè• TESTE 3: VERIFICA√á√ÉO DE CL√çNICAS');
    console.log('-'.repeat(50));
    
    try {
      // Buscar cl√≠nicas ativas
      const { data: clinics, error } = await supabase
        .from('clinics')
        .select('*')
        .eq('has_contextualization', true);
      
      if (error) {
        throw new Error(`Erro ao buscar cl√≠nicas: ${error.message}`);
      }
      
      if (!clinics || clinics.length === 0) {
        throw new Error('Nenhuma cl√≠nica com contextualiza√ß√£o encontrada');
      }
      
      console.log(`‚úÖ ${clinics.length} cl√≠nica(s) encontrada(s) com contextualiza√ß√£o`);
      
      for (const clinic of clinics) {
        console.log(`   - ${clinic.name} (ID: ${clinic.id})`);
        
        if (!clinic.whatsapp_phone) {
          this.warnings.push({
            test: 'CLINICS_AVAILABILITY',
            warning: `Cl√≠nica ${clinic.name} n√£o tem n√∫mero de WhatsApp configurado`
          });
        }
        
        if (!clinic.contextualization_data) {
          this.warnings.push({
            test: 'CLINICS_AVAILABILITY',
            warning: `Cl√≠nica ${clinic.name} n√£o tem dados de contextualiza√ß√£o`
          });
        }
      }
      
      this.testResults.push({ test: 'CLINICS_AVAILABILITY', status: 'PASS' });
      
    } catch (error) {
      console.error(`‚ùå ${error.message}`);
      this.errors.push({ test: 'CLINICS_AVAILABILITY', error: error.message });
      throw error;
    }
  }

  /**
   * Teste 4: Inicializa√ß√£o dos servi√ßos
   */
  async testServicesInitialization() {
    console.log('\n‚öôÔ∏è TESTE 4: INICIALIZA√á√ÉO DOS SERVI√áOS');
    console.log('-'.repeat(50));
    
    try {
      // Testar inicializa√ß√£o do ClinicContextManager
      console.log('üîß Inicializando ClinicContextManager...');
      await ClinicContextManager.initialize();
      console.log('‚úÖ ClinicContextManager inicializado');
      
      // Testar inicializa√ß√£o do GoogleCalendarService
      console.log('üîß Inicializando GoogleCalendarService...');
      const googleCalendar = new GoogleCalendarService();
      await googleCalendar.initialize();
      console.log('‚úÖ GoogleCalendarService inicializado');
      
      // Testar inicializa√ß√£o do AppointmentFlowManager
      console.log('üîß Inicializando AppointmentFlowManager...');
      const appointmentFlow = new AppointmentFlowManager();
      await appointmentFlow.initialize();
      console.log('‚úÖ AppointmentFlowManager inicializado');
      
      // Testar inicializa√ß√£o do LLMOrchestratorService
      console.log('üîß Inicializando LLMOrchestratorService...');
      await LLMOrchestratorService.initializeAppointmentFlow();
      console.log('‚úÖ LLMOrchestratorService inicializado');
      
      this.testResults.push({ test: 'SERVICES_INITIALIZATION', status: 'PASS' });
      
    } catch (error) {
      console.error(`‚ùå ${error.message}`);
      this.errors.push({ test: 'SERVICES_INITIALIZATION', error: error.message });
      throw error;
    }
  }

  /**
   * Teste 5: Teste de fluxo de agendamento
   */
  async testAppointmentFlow() {
    console.log('\nüìÖ TESTE 5: TESTE DE FLUXO DE AGENDAMENTO');
    console.log('-'.repeat(50));
    
    try {
      // Buscar primeira cl√≠nica dispon√≠vel
      const { data: clinics } = await supabase
        .from('clinics')
        .select('*')
        .eq('has_contextualization', true)
        .limit(1);
      
      if (!clinics || clinics.length === 0) {
        throw new Error('Nenhuma cl√≠nica dispon√≠vel para teste');
      }
      
      const clinic = clinics[0];
      console.log(`üè• Testando com cl√≠nica: ${clinic.name}`);
      
      // Testar obten√ß√£o de contexto
      const clinicContext = await ClinicContextManager.getClinicContext(clinic.name);
      
      if (!clinicContext) {
        throw new Error('N√£o foi poss√≠vel obter contexto da cl√≠nica');
      }
      
      console.log('‚úÖ Contexto da cl√≠nica obtido com sucesso');
      
      // Testar cria√ß√£o de estado de fluxo
      const appointmentFlow = new AppointmentFlowManager();
      const flowState = appointmentFlow.createNewFlowState(clinicContext);
      
      if (!flowState || !flowState.step) {
        throw new Error('Estado de fluxo n√£o foi criado corretamente');
      }
      
      console.log('‚úÖ Estado de fluxo criado com sucesso');
      
      // Testar extra√ß√£o de servi√ßos
      const services = appointmentFlow.extractServicesFromContext(clinicContext);
      
      if (!services || services.length === 0) {
        this.warnings.push({
          test: 'APPOINTMENT_FLOW',
          warning: 'Nenhum servi√ßo encontrado no contexto da cl√≠nica'
        });
      } else {
        console.log(`‚úÖ ${services.length} servi√ßo(s) extra√≠do(s) do contexto`);
      }
      
      this.testResults.push({ test: 'APPOINTMENT_FLOW', status: 'PASS' });
      
    } catch (error) {
      console.error(`‚ùå ${error.message}`);
      this.errors.push({ test: 'APPOINTMENT_FLOW', error: error.message });
    }
  }

  /**
   * Teste 6: Teste de integra√ß√£o com Google Calendar
   */
  async testGoogleCalendarIntegration() {
    console.log('\nüìÖ TESTE 6: TESTE DE INTEGRA√á√ÉO COM GOOGLE CALENDAR');
    console.log('-'.repeat(50));
    
    try {
      const googleCalendar = new GoogleCalendarService();
      
      // Verificar se as credenciais est√£o dispon√≠veis
      const credentialsPath = './config/google-credentials.json';
      
      try {
        await googleCalendar.initialize(credentialsPath);
        console.log('‚úÖ GoogleCalendarService inicializado com credenciais');
        
        // Testar verifica√ß√£o de conex√£o
        const connectionStatus = await googleCalendar.checkConnection('test-clinic');
        
        if (connectionStatus.connected) {
          console.log('‚úÖ Conex√£o com Google Calendar estabelecida');
        } else {
          console.log('‚ö†Ô∏è Conex√£o com Google Calendar n√£o estabelecida (pode ser esperado em ambiente de teste)');
        }
        
      } catch (credentialError) {
        console.log('‚ö†Ô∏è Credenciais do Google Calendar n√£o encontradas (pode ser esperado em ambiente de teste)');
        this.warnings.push({
          test: 'GOOGLE_CALENDAR_INTEGRATION',
          warning: 'Credenciais do Google Calendar n√£o configuradas'
        });
      }
      
      this.testResults.push({ test: 'GOOGLE_CALENDAR_INTEGRATION', status: 'PASS' });
      
    } catch (error) {
      console.error(`‚ùå ${error.message}`);
      this.errors.push({ test: 'GOOGLE_CALENDAR_INTEGRATION', error: error.message });
    }
  }

  /**
   * Teste 7: Teste de processamento de mensagens
   */
  async testMessageProcessing() {
    console.log('\nüí¨ TESTE 7: TESTE DE PROCESSAMENTO DE MENSAGENS');
    console.log('-'.repeat(50));
    
    try {
      // Simular mensagem de agendamento
      const testMessage = 'Gostaria de agendar uma consulta';
      const testPhoneNumber = '+5547999999999';
      
      console.log(`üì± Testando mensagem: "${testMessage}"`);
      
      // Testar detec√ß√£o de inten√ß√£o
      const intent = await LLMOrchestratorService.detectIntent(testMessage);
      
      if (!intent || !intent.name) {
        throw new Error('Detec√ß√£o de inten√ß√£o falhou');
      }
      
      console.log(`‚úÖ Inten√ß√£o detectada: ${intent.name} (confian√ßa: ${intent.confidence})`);
      
      // Verificar se √© inten√ß√£o de agendamento
      const isAppointmentIntent = LLMOrchestratorService.isAppointmentIntent(intent);
      
      if (isAppointmentIntent) {
        console.log('‚úÖ Inten√ß√£o de agendamento reconhecida corretamente');
      } else {
        console.log('‚ö†Ô∏è Mensagem n√£o foi reconhecida como inten√ß√£o de agendamento');
      }
      
      this.testResults.push({ test: 'MESSAGE_PROCESSING', status: 'PASS' });
      
    } catch (error) {
      console.error(`‚ùå ${error.message}`);
      this.errors.push({ test: 'MESSAGE_PROCESSING', error: error.message });
    }
  }

  /**
   * Teste 8: Valida√ß√£o de respostas
   */
  async testResponseValidation() {
    console.log('\n‚úÖ TESTE 8: VALIDA√á√ÉO DE RESPOSTAS');
    console.log('-'.repeat(50));
    
    try {
      // Testar gera√ß√£o de resposta de fallback
      const fallbackResponse = LLMOrchestratorService.generateIntelligentFallbackResponse(
        { name: 'GREETING' },
        { name: 'Cl√≠nica Teste' },
        true,
        true,
        { name: 'Usu√°rio Teste' },
        'Ol√°'
      );
      
      if (!fallbackResponse || fallbackResponse.length === 0) {
        throw new Error('Gera√ß√£o de resposta de fallback falhou');
      }
      
      console.log('‚úÖ Resposta de fallback gerada com sucesso');
      
      // Testar humaniza√ß√£o de respostas
      const humanizedResponse = LLMOrchestratorService.humanizationHelpers.addPersonalTouch(
        'Ol√°, como posso ajudar?',
        'Jo√£o'
      );
      
      if (!humanizedResponse || humanizedResponse.length === 0) {
        throw new Error('Humaniza√ß√£o de resposta falhou');
      }
      
      console.log('‚úÖ Humaniza√ß√£o de resposta funcionando');
      
      this.testResults.push({ test: 'RESPONSE_VALIDATION', status: 'PASS' });
      
    } catch (error) {
      console.error(`‚ùå ${error.message}`);
      this.errors.push({ test: 'RESPONSE_VALIDATION', error: error.message });
    }
  }

  /**
   * Gera relat√≥rio final
   */
  generateFinalReport() {
    console.log('\n' + '='.repeat(80));
    console.log('üìä RELAT√ìRIO FINAL DOS TESTES');
    console.log('='.repeat(80));
    
    const totalTests = this.testResults.length;
    const passedTests = this.testResults.filter(r => r.status === 'PASS').length;
    const failedTests = this.errors.length;
    const warningsCount = this.warnings.length;
    
    console.log(`\nüìà RESUMO:`);
    console.log(`   ‚úÖ Testes aprovados: ${passedTests}/${totalTests}`);
    console.log(`   ‚ùå Testes falharam: ${failedTests}`);
    console.log(`   ‚ö†Ô∏è  Avisos: ${warningsCount}`);
    
    if (this.errors.length > 0) {
      console.log(`\n‚ùå ERROS ENCONTRADOS:`);
      this.errors.forEach((error, index) => {
        console.log(`   ${index + 1}. [${error.test}] ${error.error}`);
      });
    }
    
    if (this.warnings.length > 0) {
      console.log(`\n‚ö†Ô∏è  AVISOS:`);
      this.warnings.forEach((warning, index) => {
        console.log(`   ${index + 1}. [${warning.test}] ${warning.warning}`);
      });
    }
    
    if (failedTests === 0) {
      console.log(`\nüéâ SISTEMA DE AGENDAMENTO APROVADO! Pode prosseguir com os testes.`);
    } else {
      console.log(`\nüö® SISTEMA DE AGENDAMENTO COM PROBLEMAS! Corrija os erros antes de prosseguir.`);
      process.exit(1);
    }
  }
}

// Executar testes se o arquivo for executado diretamente
if (import.meta.url === `file://${process.argv[1]}`) {
  const tester = new AppointmentSystemE2ETest();
  tester.runAllTests().catch(error => {
    console.error('üí• ERRO FATAL NO TESTE:', error);
    process.exit(1);
  });
}

export default AppointmentSystemE2ETest;
