// services/core/llmOrchestratorService.js
// Vers√£o simplificada que usa APENAS JSONs via ClinicContextManager

import OpenAI from 'openai';
import config from '../config/index.js';
import logger from '../utils/logger.js';

// ‚úÖ IMPORTS SIMPLIFICADOS
import HumanizationHelpers from './humanizationHelpers.js';
import AppointmentFlowManager from './appointmentFlowManager.js';
import ClinicContextManager from './clinicContextManager.js';

// Configura√ß√£o do Supabase (centralizada)
const supabase = config.getSupabaseClient();

// Configura√ß√£o do OpenAI
const openai = new OpenAI({
  apiKey: config.OPENAI_API_KEY,
  ...(config.OPENAI_BASE_URL ? { baseURL: config.OPENAI_BASE_URL } : {}),
});

export default class LLMOrchestratorService {
  // ‚úÖ PROPRIEDADES SIMPLIFICADAS
  static humanizationHelpers = HumanizationHelpers;
  static appointmentFlowManager = null;
  static conversationMetrics = new Map();
  
  // ‚úÖ INICIALIZA√á√ÉO ROBUSTA DO APPOINTMENT FLOW MANAGER
  static async initializeAppointmentFlow() {
    try {
      console.log('üîß [LLMOrchestrator] Iniciando inicializa√ß√£o do AppointmentFlowManager...');
      
      if (!this.appointmentFlowManager) {
        console.log('üîß [LLMOrchestrator] Criando nova inst√¢ncia do AppointmentFlowManager...');
        this.appointmentFlowManager = new AppointmentFlowManager(this);
        
        console.log('üîß [LLMOrchestrator] Inicializando AppointmentFlowManager...');
        await this.appointmentFlowManager.initialize();
        
        console.log('‚úÖ [LLMOrchestrator] AppointmentFlowManager inicializado com sucesso');
        logger.info('AppointmentFlowManager inicializado com sucesso');
        
        // ‚úÖ VALIDA√á√ÉO: Verificar se realmente foi inicializado
        if (!this.appointmentFlowManager.initialized) {
          throw new Error('AppointmentFlowManager n√£o foi inicializado corretamente');
        }
        
        console.log('‚úÖ [LLMOrchestrator] Valida√ß√£o de inicializa√ß√£o passou');
      } else {
        console.log('‚úÖ [LLMOrchestrator] AppointmentFlowManager j√° existe e est√° inicializado');
      }
      
      return this.appointmentFlowManager;
      
    } catch (error) {
      console.error('‚ùå [LLMOrchestrator] Erro ao inicializar AppointmentFlowManager:', error);
      logger.error('Erro ao inicializar AppointmentFlowManager', { message: error.message });
      
      // üîß CORRE√á√ÉO: Limpar inst√¢ncia falhada e tentar novamente
      this.appointmentFlowManager = null;
      
      // üîß CORRE√á√ÉO: Retry logic
      try {
        console.log('üîÑ [LLMOrchestrator] Tentando reinicializa√ß√£o...');
        this.appointmentFlowManager = new AppointmentFlowManager(this);
        await this.appointmentFlowManager.initialize();
        console.log('‚úÖ [LLMOrchestrator] Reinicializa√ß√£o bem-sucedida');
        return this.appointmentFlowManager;
      } catch (retryError) {
        console.error('‚ùå [LLMOrchestrator] Falha na reinicializa√ß√£o:', retryError);
        logger.error('Falha na reinicializa√ß√£o do AppointmentFlowManager', { message: retryError.message });
        throw retryError;
      }
    }
  }

  // ‚úÖ PROCESSAMENTO PRINCIPAL DE MENSAGENS
  static async processMessage(request) {
    try {
      const { generateTraceId } = await import('../utils/trace.js');
      const traceId = generateTraceId();
      logger.info('LLMOrchestrator processing', { traceId });

      const { phoneNumber, message, conversationId, userId } = request;

      // Sistema de mem√≥ria simples
      const { default: ConversationMemoryRepository } = await import('./conversationMemoryRepository.js');
      const memoryRepo = new ConversationMemoryRepository();
      const memory = await memoryRepo.load(phoneNumber);
      
      // Extrair nome do usu√°rio se presente na mensagem
      const extractedName = this.extractUserName(message);
      if (extractedName && !memory.userProfile?.name) {
        memory.userProfile = memory.userProfile || {};
        memory.userProfile.name = extractedName;
        logger.info('Nome extra√≠do e salvo', { traceId, extractedName });
        
        // Salvar nome na tabela conversation_memory
        await memoryRepo.saveName(phoneNumber, extractedName);
      }
      
      // ‚úÖ BUSCAR CONTEXTO APENAS DO JSON (sem banco de dados)
      // üîß CORRE√á√ÉO: Identificar cl√≠nica baseada no n√∫mero do WhatsApp
      // Primeiro, precisamos identificar qual cl√≠nica est√° recebendo a mensagem
      // Vamos buscar todas as cl√≠nicas e verificar qual tem o n√∫mero de WhatsApp ativo
      const supabase = config.getSupabaseClient();
      
      // üîß CORRE√á√ÉO: Buscar cl√≠nica que est√° recebendo a mensagem
      // Como estamos no webhook, a mensagem est√° sendo enviada PARA uma cl√≠nica
      // Vamos buscar a cl√≠nica que tem o n√∫mero de WhatsApp ativo
      const { data: activeClinics, error: clinicsError } = await supabase
        .from('clinics')
        .select('name, whatsapp_phone, id, has_contextualization')
        .eq('has_contextualization', true);
      
      if (clinicsError) {
        logger.error('[LLMOrchestrator] Erro ao buscar cl√≠nicas ativas', { traceId, error: clinicsError.message });
        throw new Error('Erro ao buscar cl√≠nicas ativas');
      }
      
      if (!activeClinics || activeClinics.length === 0) {
        logger.error('[LLMOrchestrator] Nenhuma cl√≠nica com contextualiza√ß√£o encontrada', { traceId });
        throw new Error('Nenhuma cl√≠nica com contextualiza√ß√£o encontrada');
      }
      
      // üîß ROTEAMENTO DETERMIN√çSTICO: resolver cl√≠nica a partir dos dados do webhook
      const { phoneNumberId, displayPhoneNumber } = request || {};
      const { default: ClinicRoutingRepository } = await import('./clinicRoutingRepository.js');
      const routingRepo = new ClinicRoutingRepository();
      const clinicId = await routingRepo.resolveClinicByWebhook({
        phoneNumberId,
        displayPhoneNumber,
        patientPhone: phoneNumber,
      });

      let clinicKey;
      if (clinicId) {
        // Buscar nome da cl√≠nica pelo id
        const { data: clinicRow, error: clinicFetchError } = await supabase
          .from('clinics')
          .select('name')
          .eq('id', clinicId)
          .maybeSingle();
        if (!clinicFetchError && clinicRow?.name) {
          clinicKey = clinicRow.name;
          logger.info('[LLMOrchestrator] Cl√≠nica resolvida por roteamento', { traceId, clinicKey, clinicId });
        }
      }

      // Fallback somente se n√£o resolvido por roteamento
      if (!clinicKey) {
        if (activeClinics.length === 1) {
          clinicKey = activeClinics[0].name;
          logger.info('[LLMOrchestrator] Usando √∫nica cl√≠nica dispon√≠vel', { traceId, clinicKey });
        } else {
          clinicKey = activeClinics[0].name;
          logger.warn('[LLMOrchestrator] Roteamento n√£o determin√≠stico, usando primeira cl√≠nica', { traceId, clinicKey });
        }
      }

      logger.info('[LLMOrchestrator] Cl√≠nica selecionada', { traceId, clinicKey });

      let clinicContext;
      try {
        clinicContext = await ClinicContextManager.getClinicContext(clinicKey);
        logger.info('[LLMOrchestrator] Contexto obtido para cl√≠nica', { traceId, clinicKey });
      } catch (contextError) {
        logger.error('[LLMOrchestrator] Erro ao obter contexto da cl√≠nica', { traceId, clinicKey, error: contextError.message });
        throw new Error(`N√£o foi poss√≠vel obter contexto da cl√≠nica ${clinicKey}: ${contextError.message}`);
      }

      // Detectar inten√ß√£o avan√ßada com hist√≥rico e contexto
      const conversationHistory = memory.history || [];
      const { default: IntentDetector } = await import('./intentDetector.js');
      const intentDetector = new IntentDetector();
      const intent = await intentDetector.detect(message, conversationHistory, clinicContext);

      // INICIALIZAR APPOINTMENT FLOW MANAGER SE NECESS√ÅRIO
      if (this.isAppointmentIntent(intent)) {
        await this.initializeAppointmentFlow();
      }

      // Verificar se √© primeira conversa do dia
      const isFirstConversationOfDay = await this.isFirstConversationOfDay(phoneNumber);
      logger.info('Primeira conversa do dia?', { traceId, isFirstConversationOfDay });

      // Verificar hor√°rio de funcionamento
      const isWithinBusinessHours = this.isWithinBusinessHours(clinicContext);
      logger.info('Dentro do hor√°rio de funcionamento?', { traceId, isWithinBusinessHours });

      // Preparar prompt do sistema com perfil do usu√°rio
      const { default: ResponseFormatter } = await import('./responseFormatter.js');
      const systemPrompt = ResponseFormatter.prepareSystemPrompt(clinicContext, memory.userProfile);

      // Filtrar do hist√≥rico quaisquer respostas de "fora do hor√°rio" quando estamos DENTRO do expediente
      let memoryForPrompt = memory;
      try {
        if (isWithinBusinessHours && Array.isArray(memory.history)) {
          const outOfHoursRegex = /(fora do hor√°rio|No momento estamos|pr√≥ximo hor√°rio comercial|Retornaremos seu contato)/i;
          const filteredHistory = memory.history.filter(entry => {
            if (entry && typeof entry === 'object') {
              if (entry.bot && outOfHoursRegex.test(entry.bot)) return false;
              if (entry.role === 'assistant' && entry.content && outOfHoursRegex.test(entry.content)) return false;
            }
            return true;
          });
          if (filteredHistory.length !== memory.history.length) {
            logger.info('Removendo mensagens hist√≥ricas de fora do hor√°rio por estar dentro do expediente', { traceId, removed: memory.history.length - filteredHistory.length });
          }
          memoryForPrompt = { ...memory, history: filteredHistory };
        }
      } catch (e) {
        logger.warn('Falha ao filtrar hist√≥rico para fora do hor√°rio (seguindo sem filtro)', { message: e.message });
      }

      // Construir mensagens para o LLM usando o hist√≥rico filtrado (se aplic√°vel)
      const messages = ResponseFormatter.buildMessages(systemPrompt, memoryForPrompt, message);

      // VERIFICAR SE √â INTEN√á√ÉO DE AGENDAMENTO
      if (this.isAppointmentIntent(intent)) {
        logger.info('Inten√ß√£o de agendamento detectada', { traceId, message });
        
        // üîß CORRE√á√ÉO: Validar hor√°rio de funcionamento ANTES de processar agendamento
        if (!isWithinBusinessHours) {
          logger.info('Fora do hor√°rio de funcionamento', { traceId });
          const outOfHoursMessage = clinicContext.agentConfig?.mensagem_fora_horario || 
            'No momento estamos fora do hor√°rio de atendimento. Retornaremos seu contato no pr√≥ximo hor√°rio comercial.';
          
          return {
            response: outOfHoursMessage,
            intent: intent,
            toolsUsed: ['clinic_context', 'business_hours_validation'],
            metadata: {
              clinic: clinicContext.name,
              agent: clinicContext.agentConfig?.nome,
              businessHoursValidation: 'REJECTED_OUT_OF_HOURS'
            }
          };
        }
        
        try {
          // üîß CORRE√á√ÉO: Garantir que AppointmentFlowManager est√° inicializado
          console.log('üîß [LLMOrchestrator] Verificando AppointmentFlowManager...');
          if (!this.appointmentFlowManager) {
            console.log('üîß [LLMOrchestrator] AppointmentFlowManager n√£o encontrado, inicializando...');
            await this.initializeAppointmentFlow();
          }
          
          // üîß CORRE√á√ÉO: Validar se AppointmentFlowManager foi inicializado com sucesso
          if (!this.appointmentFlowManager || !this.appointmentFlowManager.initialized) {
            console.error('‚ùå [LLMOrchestrator] AppointmentFlowManager n√£o est√° dispon√≠vel ap√≥s inicializa√ß√£o');
            throw new Error('AppointmentFlowManager n√£o est√° dispon√≠vel');
          }
          
          console.log('‚úÖ [LLMOrchestrator] AppointmentFlowManager validado, roteando...');
          logger.info('Roteando para ferramenta apropriada...', { traceId });
          
          const { default: ToolsRouter } = await import('./toolsRouter.js');
          const toolsRouter = new ToolsRouter({ appointmentFlowManager: this.appointmentFlowManager });
          
          console.log('üîß [LLMOrchestrator] ToolsRouter criado, chamando roteamento...');
          const appointmentResult = await toolsRouter.route({
            phoneNumber,
            message,
            intent,
            clinicContext,
            memory,
            traceId,
          });
          
          console.log('‚úÖ [LLMOrchestrator] Resultado do roteamento:', {
            hasResult: !!appointmentResult,
            hasResponse: !!appointmentResult?.response,
            hasError: !!appointmentResult?.error,
            flowStep: appointmentResult?.metadata?.flowStep
          });
          
          logger.info('Resultado do AppointmentFlowManager obtido', { traceId, success: !!appointmentResult?.success });
          
          if (appointmentResult && appointmentResult.success) {
            return appointmentResult;
          } else if (appointmentResult && appointmentResult.response) {
            return appointmentResult;
          }
          
          // üîß CORRE√á√ÉO: Se n√£o h√° resultado v√°lido, retornar erro
          console.warn('‚ö†Ô∏è [LLMOrchestrator] AppointmentFlowManager n√£o retornou resultado v√°lido');
          return {
            response: 'Desculpe, n√£o consegui processar sua solicita√ß√£o de agendamento. Por favor, tente novamente ou entre em contato pelo telefone.',
            intent: { name: 'APPOINTMENT_ERROR', confidence: 0.8 },
            toolsUsed: ['appointment_flow'],
            metadata: { error: 'no_valid_result', flowStep: 'error' }
          };
          
        } catch (error) {
          console.error('‚ùå [LLMOrchestrator] Erro no AppointmentFlowManager:', error);
          logger.error('Erro no AppointmentFlowManager', { traceId, error: error.message });
          
          // üîß CORRE√á√ÉO: Retornar resposta de erro √∫til
          return {
            response: 'Desculpe, ocorreu um erro t√©cnico no sistema de agendamento. Por favor, entre em contato conosco pelo telefone para agendar sua consulta.',
            intent: { name: 'APPOINTMENT_ERROR', confidence: 0.8 },
            toolsUsed: ['appointment_flow'],
            metadata: { error: 'appointment_flow_error', errorMessage: error.message }
          };
        }
      }

      // üîß CORRE√á√ÉO: Verificar se h√° fluxo de agendamento ativo para continuar
      if (this.appointmentFlowManager && await this.appointmentFlowManager.hasActiveFlow(phoneNumber)) {
        logger.info('Fluxo de agendamento ativo detectado, continuando...', { traceId });
        
        try {
          const flowState = await this.appointmentFlowManager.getFlowState(phoneNumber);
          logger.info('Estado atual do fluxo', { traceId, step: flowState.step });
          
          const continuation = await this.appointmentFlowManager.continueExistingFlow(
            phoneNumber, message, clinicContext, memory, flowState
          );
          
          logger.info('Continua√ß√£o do fluxo conclu√≠da', { traceId });
          return continuation;
        } catch (error) {
          logger.error('Erro ao continuar fluxo de agendamento', { traceId, error: error.message });
        }
      }

      // ‚úÖ PROCESSAMENTO NORMAL COM LLM
      logger.info('Processando com OpenAI...', { traceId });
      
      const completion = await openai.chat.completions.create({
        model: "gpt-4o-mini",
        messages: messages,
        max_tokens: 500,
        temperature: 0.7,
        presence_penalty: 0.1,
        frequency_penalty: 0.1
      });
      
      const response = completion.choices[0].message.content;
      
      // ‚úÖ APLICAR L√ìGICA DE RESPOSTA (sauda√ß√£o, hor√°rio, sanitiza√ß√£o)
      const finalResponse = await this.applyResponseLogic(
        response,
        clinicContext,
        isFirstConversationOfDay,
        isWithinBusinessHours,
        memory.userProfile,
        conversationHistory
      );
      
      // Salvar na mem√≥ria
      await memoryRepo.append(phoneNumber, message, finalResponse, intent, memory.userProfile, memory.history);
      
      logger.info('Resposta final gerada', { traceId });
      
      return {
        response: finalResponse,
        intent: intent,
        toolsUsed: ['openai', 'clinic_context'],
        metadata: {
          model: 'gpt-4o-mini',
          tokens: completion.usage?.total_tokens || 0,
          clinic: clinicContext.name,
          agent: clinicContext.agentConfig?.nome
        }
      };
    } catch (error) {
      logger.error('Erro no processamento principal', { message: error.message });
      throw error;
    }
  }

  // ‚úÖ FUN√á√ÉO REMOVIDA: Agora usa ClinicContextManager diretamente

  // ‚úÖ FUN√á√ïES AUXILIARES
  static extractUserName(message) {
    // L√≥gica para extrair nome do usu√°rio
    const namePatterns = [
      /meu nome √© (\w+)/i,
      /sou o (\w+)/i,
      /sou a (\w+)/i,
      /chamo-me (\w+)/i,
      /me chamo (\w+)/i
    ];
    
    for (const pattern of namePatterns) {
      const match = message.match(pattern);
      if (match) {
        return match[1];
      }
    }
    
    return null;
  }

  static async saveUserName(phoneNumber, name) {
    try {
      const { error } = await supabase
        .from('conversation_memory')
        .upsert({
          phone_number: phoneNumber,
          user_name: JSON.stringify({
            name: name,
            extracted_at: new Date().toISOString()
          }),
          last_interaction: new Date().toISOString()
        }, { onConflict: 'phone_number' });
      
      if (error) throw error;
      console.log(`‚úÖ Nome salvo para ${phoneNumber}: ${name}`);
    } catch (error) {
      console.error('‚ùå Erro ao salvar nome:', error);
    }
  }

  static async loadConversationMemory(phoneNumber) {
    try {
      const { data, error } = await supabase
        .from('conversation_memory')
        .select('memory_data, user_name')
        .eq('phone_number', phoneNumber)
        .single();
      
      if (error && error.code !== 'PGRST116') throw error;
      
      if (data) {
        let userProfile = {};
        
        // Extrair nome do usu√°rio do user_name (JSON string)
        if (data.user_name) {
          try {
            if (typeof data.user_name === 'string') {
              if (data.user_name.startsWith('{') && data.user_name.endsWith('}')) {
                const parsedUserName = JSON.parse(data.user_name);
                userProfile.name = parsedUserName.name;
              } else {
                userProfile.name = data.user_name;
              }
            } else if (data.user_name.name) {
              userProfile.name = data.user_name.name;
            }
          } catch (error) {
            console.error('Error parsing user_name:', error);
            userProfile.name = data.user_name;
          }
        }
        
        return {
          userProfile: userProfile,
          history: data.memory_data?.history || [],
          lastUpdated: data.last_interaction
        };
      }
      
      return {
        userProfile: {},
        history: [],
        lastUpdated: null
      };
    } catch (error) {
      console.error('‚ùå Erro ao carregar mem√≥ria:', error);
      return {
        userProfile: {},
        history: [],
        lastUpdated: null
      };
    }
  }

  static async saveConversationMemory(phoneNumber, userMessage, botResponse, intent) {
    try {
      const memory = await this.loadConversationMemory(phoneNumber);
      
      const newHistory = [
        ...memory.history,
        {
          timestamp: new Date().toISOString(),
          user: userMessage,
          bot: botResponse,
          intent: intent?.name || 'UNKNOWN'
        }
      ];
      
      // Manter apenas as √∫ltimas 10 mensagens
      const trimmedHistory = newHistory.slice(-10);
      
      const { error } = await supabase
        .from('conversation_memory')
        .upsert({
          phone_number: phoneNumber,
          memory_data: {
            history: trimmedHistory,
            userProfile: memory.userProfile
          },
          last_interaction: new Date().toISOString()
        }, { onConflict: 'phone_number' });
      
      if (error) throw error;
      console.log('‚úÖ Mem√≥ria de conversa salva');
    } catch (error) {
      console.error('‚ùå Erro ao salvar mem√≥ria:', error);
    }
  }

  /**
   * Detecta inten√ß√£o da mensagem usando LLM avan√ßado
   * @param {string} message - Mensagem do usu√°rio
   * @param {Array} conversationHistory - Hist√≥rico da conversa
   * @param {Object} clinicContext - Contexto da cl√≠nica
   */
  static async detectIntent(message, conversationHistory = [], clinicContext = {}) {
    try {
      console.log('üéØ [LLMOrchestrator] Detectando inten√ß√£o avan√ßada com LLM:', { 
        messageLength: message.length,
        historyLength: conversationHistory.length,
        hasClinicContext: !!clinicContext
      });

      // üîß CORRE√á√ÉO: Usar sistema avan√ßado de detec√ß√£o de inten√ß√£o
      const prompt = `You are an intent recognition system for a medical clinic's WhatsApp chatbot.
Analyze the user message and conversation history to identify the intent.

Available intents:
- APPOINTMENT_CREATE: User wants to schedule an appointment
- APPOINTMENT_RESCHEDULE: User wants to change an existing appointment
- APPOINTMENT_CANCEL: User wants to cancel an appointment
- APPOINTMENT_LIST: User wants to see their appointments
- INFO_HOURS: Asking about clinic hours
- INFO_LOCATION: Asking about clinic address/location
- INFO_SERVICES: Asking about available services/specialties
- INFO_DOCTORS: Asking about doctors/professionals
- INFO_PRICES: Asking about prices/insurance
- INFO_GENERAL: General information questions
- GREETING: Greeting messages
- FAREWELL: Goodbye messages
- HUMAN_HANDOFF: User wants to speak with a human
- UNCLEAR: Intent is not clear

Extract entities like: dates, times, doctor names, services, symptoms, etc.

Current message: "${message}"

Conversation history:
${conversationHistory.map(h => `${h.role}: ${h.content}`).join('\n')}

Clinic context:
- Services: ${JSON.stringify(clinicContext.services || [])}
- Doctors: ${JSON.stringify(clinicContext.professionals || [])}

Return a JSON with: { "intent": "INTENT_NAME", "confidence": 0.0-1.0, "entities": {}, "reasoning": "brief explanation" }`;

      // üîß CORRE√á√ÉO: Usar OpenAI para detec√ß√£o inteligente
      const { OpenAI } = await import('openai');
      const openai = new OpenAI({
        apiKey: process.env.OPENAI_API_KEY,
      });

      const completion = await openai.chat.completions.create({
        model: 'gpt-4o-mini', // Usar modelo mais econ√¥mico para detec√ß√£o
        messages: [{ role: 'user', content: prompt }],
        temperature: 0.1,
        max_tokens: 200,
      });

      const response = completion.choices[0]?.message?.content;
      console.log('ü§ñ [LLMOrchestrator] Resposta do LLM para detec√ß√£o:', response);

      let intentData;
      try {
        // Limpar a resposta removendo markdown e extraindo apenas o JSON
        let cleanResponse = response;
        
        // Remover ```json e ``` se presentes
        cleanResponse = cleanResponse.replace(/```json\s*/g, '').replace(/```\s*/g, '');
        
        // Se ainda n√£o for JSON v√°lido, tentar extrair JSON do texto
        if (!cleanResponse.trim().startsWith('{')) {
          const jsonMatch = cleanResponse.match(/\{[\s\S]*\}/);
          if (jsonMatch) {
            cleanResponse = jsonMatch[0];
          }
        }
        
        intentData = JSON.parse(cleanResponse.trim());
      } catch (parseError) {
        console.error('‚ùå [LLMOrchestrator] Erro ao fazer parse da resposta LLM:', parseError);
        console.error('‚ùå [LLMOrchestrator] Resposta original:', response);
        console.log('üîÑ Usando fallback com keywords...');
        return this.fallbackIntentRecognition(message);
      }

      console.log('‚úÖ [LLMOrchestrator] Inten√ß√£o detectada pelo LLM:', {
        intent: intentData.intent,
        confidence: intentData.confidence,
        entities: intentData.entities,
        reasoning: intentData.reasoning
      });

      return {
        name: intentData.intent,
        confidence: intentData.confidence || 0.8,
        entities: intentData.entities || {},
        requiresAction: this.isAppointmentIntent(intentData.intent),
        category: this.mapIntentToCategory(intentData.intent)
      };

    } catch (error) {
      console.error('‚ùå [LLMOrchestrator] Erro na detec√ß√£o avan√ßada de inten√ß√£o:', error);
      console.log('üîÑ Usando fallback com keywords...');
      return this.fallbackIntentRecognition(message);
    }
  }

  static fallbackIntentRecognition(message) {
    const lowerMessage = message.toLowerCase();
    
    // Padr√µes mais espec√≠ficos
    if (lowerMessage.includes('hor√°rio') || lowerMessage.includes('funcionamento')) {
      return { name: 'SCHEDULE_INFO', confidence: 0.7 };
    }
    
    if (lowerMessage.includes('pre√ßo') || lowerMessage.includes('valor') || lowerMessage.includes('custo')) {
      return { name: 'PRICING_INFO', confidence: 0.7 };
    }
    
    if (lowerMessage.includes('endere√ßo') || lowerMessage.includes('localiza√ß√£o')) {
      return { name: 'LOCATION_INFO', confidence: 0.7 };
    }
    
    if (lowerMessage.includes('telefone') || lowerMessage.includes('contato')) {
      return { name: 'CONTACT_INFO', confidence: 0.7 };
    }
    
    // Padr√£o gen√©rico
    return { name: 'GENERAL_QUERY', confidence: 0.5 };
  }

  static containsAppointmentKeywords(message) {
    // üîß CORRE√á√ÉO: Expandir keywords para melhor detec√ß√£o de agendamento
    const keywords = [
      'agendar', 'consulta', 'marcar', 'agendamento', 'marca√ß√£o',
      'realizar', 'fazer', 'quero', 'preciso', 'gostaria',
      'agendar consulta', 'marcar consulta', 'agendar exame',
      'marcar exame', 'agendar hor√°rio', 'marcar hor√°rio',
      'agendar atendimento', 'marcar atendimento'
    ];
    
    const lowerMessage = message.toLowerCase();
    const hasKeyword = keywords.some(keyword => lowerMessage.includes(keyword));
    
    console.log('üîç Verificando keywords de agendamento:', {
      message: message,
      lowerMessage: lowerMessage,
      keywords: keywords,
      hasKeyword: hasKeyword
    });
    
    return hasKeyword;
  }

  static containsInfoKeywords(message) {
    const keywords = ['informa√ß√£o', 'saber', 'conhecer', 'quais', 'como', 'onde', 'quando'];
    return keywords.some(keyword => message.includes(keyword));
  }

  static containsGreetingKeywords(message) {
    const keywords = ['oi', 'ol√°', 'bom dia', 'boa tarde', 'boa noite'];
    return keywords.some(keyword => message.includes(keyword));
  }

  static isAppointmentIntent(intent) {
    // üîß CORRE√á√ÉO: Verificar se intent existe e tem propriedades v√°lidas
    if (!intent || !intent.name) {
      console.log('üîç Intent inv√°lido ou sem nome:', intent);
      return false;
    }
    
    // üîß CORRE√á√ÉO: Expandir reconhecimento para inten√ß√µes espec√≠ficas do LLM
    const appointmentIntents = [
      'APPOINTMENT', 'APPOINTMENT_CREATE', 'APPOINTMENT_SCHEDULE',
      'SCHEDULE_INFO', 'SCHEDULING', 'BOOKING', 'BOOK_APPOINTMENT',
      // Novas inten√ß√µes espec√≠ficas do LLM
      'APPOINTMENT_RESCHEDULE', 'APPOINTMENT_CANCEL', 'APPOINTMENT_LIST'
    ];
    
    const result = appointmentIntents.includes(intent.name) || 
                  (typeof intent.name === 'string' && intent.name.includes('APPOINTMENT')) ||
                  (typeof intent.name === 'string' && intent.name.includes('SCHEDULE')) ||
                  (typeof intent.name === 'string' && intent.name.includes('BOOKING'));
    
    console.log('üîç Verificando se √© inten√ß√£o de agendamento:', {
      intent: intent.name,
      isAppointment: result,
      checkedIntents: appointmentIntents
    });
    
    return result;
  }

  static mapIntentToCategory(intentName) {
    // üîß CORRE√á√ÉO: Expandir categorias para inten√ß√µes espec√≠ficas do LLM
    const categories = {
      // Inten√ß√µes de agendamento
      'APPOINTMENT': 'scheduling',
      'APPOINTMENT_CREATE': 'scheduling',
      'APPOINTMENT_SCHEDULE': 'scheduling',
      'APPOINTMENT_RESCHEDULE': 'scheduling',
      'APPOINTMENT_CANCEL': 'scheduling',
      'APPOINTMENT_LIST': 'scheduling',
      
      // Inten√ß√µes de informa√ß√£o
      'INFORMATION': 'information',
      'INFO_HOURS': 'information',
      'INFO_LOCATION': 'information',
      'INFO_SERVICES': 'information',
      'INFO_DOCTORS': 'information',
      'INFO_PRICES': 'information',
      'INFO_GENERAL': 'information',
      
      // Inten√ß√µes de conversa√ß√£o
      'GREETING': 'conversation',
      'FAREWELL': 'conversation',
      
      // Inten√ß√µes especiais
      'SCHEDULE_INFO': 'information',
      'SCHEDULING': 'scheduling',
      'BOOKING': 'scheduling',
      'BOOK_APPOINTMENT': 'scheduling',
      'HUMAN_HANDOFF': 'escalation',
      'UNCLEAR': 'clarification'
    };
    
    return categories[intentName] || 'general';
  }

  // ‚úÖ PREPARA√á√ÉO DO PROMPT DO SISTEMA
  static prepareSystemPrompt(clinicContext, userProfile = null) {
    // ‚úÖ CONFIGURA√á√ïES DO AGENTE IA DO JSON
    const agentConfig = clinicContext.agentConfig || {};
    const agentBehavior = clinicContext.agentBehavior || {};
    const agentRestrictions = clinicContext.agentRestrictions || {};
    
    // Nome do agente (padr√£o ou do JSON)
    const agentName = agentConfig.nome || 'Assistente Virtual';
    
    // Personalidade do agente (padr√£o ou do JSON)
    const agentPersonality = agentConfig.personalidade || 'profissional, emp√°tica e prestativa';
    
    // Tom de comunica√ß√£o (padr√£o ou do JSON)
    const communicationTone = agentConfig.tom_comunicacao || 'Formal mas acess√≠vel';
    
    // N√≠vel de formalidade (padr√£o ou do JSON)
    const formalityLevel = agentConfig.nivel_formalidade || 'M√©dio';
    
    // Sauda√ß√£o inicial (padr√£o ou do JSON)
    const initialGreeting = agentConfig.saudacao_inicial || `Ol√°! Sou o ${agentName}, assistente virtual da ${clinicContext.name}. Como posso ajud√°-lo hoje?`;
    
    // Mensagem de despedida (padr√£o ou do JSON)
    const farewellMessage = agentConfig.mensagem_despedida || 'Obrigado por escolher nossa cl√≠nica. At√© breve!';
    
    // Mensagem fora do hor√°rio (padr√£o ou do JSON)
    const outOfHoursMessage = agentConfig.mensagem_fora_horario || 'No momento estamos fora do hor√°rio de atendimento. Retornaremos seu contato no pr√≥ximo hor√°rio comercial.';
    
    // ‚úÖ RESTRI√á√ïES ESPEC√çFICAS DO JSON
    const restrictions = [];
    if (agentRestrictions.nao_pode_diagnosticar) {
      restrictions.push('NUNCA fa√ßa diagn√≥sticos m√©dicos');
    }
    if (agentRestrictions.nao_pode_prescrever) {
      restrictions.push('NUNCA prescreva medicamentos');
    }
    
    // ‚úÖ EMERG√äNCIAS CARD√çACAS DO JSON (se configuradas)
    const cardiacEmergencies = agentRestrictions.emergencias_cardiacas || [];
    
    let prompt = `Voc√™ √© ${agentName}, assistente virtual da ${clinicContext.name}.
Sua personalidade √©: ${agentPersonality}
Tom de comunica√ß√£o: ${communicationTone}
N√≠vel de formalidade: ${formalityLevel}

DIRETRIZES FUNDAMENTAIS:
1. Use EXCLUSIVAMENTE as informa√ß√µes fornecidas no contexto da cl√≠nica
2. Seja sempre cordial, profissional e emp√°tico
3. Para agendamentos, oriente o usu√°rio sobre o processo
4. Se n√£o souber uma informa√ß√£o, diga educadamente que n√£o possui essa informa√ß√£o
5. ${restrictions.length > 0 ? restrictions.join(', ') : 'NUNCA invente informa√ß√µes ou d√™ conselhos m√©dicos'}
6. Mantenha respostas concisas e objetivas (m√°ximo 3 par√°grafos)
7. üîß CR√çTICO: Use SEMPRE o nome do usu√°rio quando dispon√≠vel para personalizar a conversa
8. Se o usu√°rio perguntar sobre seu nome, responda com: "${agentName}"
9. üîß CR√çTICO: NUNCA adicione sauda√ß√µes como "Ol√°", "Sou o Cardio" ou "assistente virtual da CardioPrime" no in√≠cio das respostas
10. üîß CR√çTICO: NUNCA adicione mensagens finais como "Como posso ajud√°-lo hoje" - o sistema far√° isso automaticamente
11. üîß CR√çTICO: NUNCA adicione mensagens de despedida como "At√© breve" - use apenas quando o usu√°rio finalizar conversa
12. üîß CR√çTICO: Mantenha a conversa fluida e natural, sem padr√µes repetitivos
13. üîß CR√çTICO: Responda diretamente √† pergunta do usu√°rio, sem introdu√ß√µes desnecess√°rias

INFORMA√á√ïES COMPLETAS DA CL√çNICA:
- Nome: ${clinicContext.name}
- Endere√ßo: ${clinicContext.address?.rua ? `${clinicContext.address.rua}, ${clinicContext.address.numero} - ${clinicContext.address.bairro}, ${clinicContext.address.cidade}/${clinicContext.address.estado}` : 'N√£o informado'}
- Telefone: ${clinicContext.contacts?.telefone || 'N√£o informado'}
- Email: ${clinicContext.contacts?.email_principal || 'N√£o informado'}
- Website: ${clinicContext.contacts?.website || 'N√£o informado'}
- Descri√ß√£o: ${clinicContext.basicInfo?.descricao || 'N√£o informado'}
- Especialidade: ${clinicContext.basicInfo?.especialidade || 'N√£o informado'}

SERVI√áOS DISPON√çVEIS (INFORMA√á√ïES COMPLETAS):
${clinicContext.servicesDetails ? 
  Object.entries(clinicContext.servicesDetails).map(([category, items]) => {
    if (items && Array.isArray(items) && items.length > 0) {
      return `${category.charAt(0).toUpperCase() + category.slice(1)}:\n${items.map(item => {
        let serviceInfo = `  * ${item.nome || item.nome_servico}`;
        
        // Adicionar dura√ß√£o se dispon√≠vel
        if (item.duracao_minutos) {
          serviceInfo += ` (${item.duracao_minutos} min)`;
        } else if (item.duracao) {
          serviceInfo += ` (${item.duracao})`;
        }
        
        // Adicionar tipo se dispon√≠vel
        if (item.tipo) {
          serviceInfo += ` - ${item.tipo}`;
        }
        
        // Adicionar descri√ß√£o se dispon√≠vel
        if (item.descricao) {
          serviceInfo += `: ${item.descricao}`;
        }
        
        // üîß CR√çTICO: Adicionar PRE√áO se dispon√≠vel
        if (item.preco_particular) {
          serviceInfo += ` - Pre√ßo: R$ ${item.preco_particular}`;
        }
        
        // Adicionar prepara√ß√£o se dispon√≠vel
        if (item.preparacao_necessaria) {
          serviceInfo += ` - Prepara√ß√£o: ${item.preparacao_necessaria}`;
        }
        
        // Adicionar prazo do resultado se dispon√≠vel
        if (item.resultado_prazo_dias) {
          serviceInfo += ` - Resultado em ${item.resultado_prazo_dias} dia(s)`;
        }
        
        return serviceInfo;
      }).join('\n')}`;
    }
    return '';
  }).filter(Boolean).join('\n\n') : 
  (clinicContext.services && clinicContext.services.length > 0 ? 
    clinicContext.services.map(s => `* ${s.nome || s.nome_servico}`).join('\n') : 
    'N√£o informado'
  )
}

PROFISSIONAIS DA CL√çNICA (INFORMA√á√ïES COMPLETAS):
${clinicContext.professionalsDetails && clinicContext.professionalsDetails.length > 0 ? 
  clinicContext.professionalsDetails.map(prof => 
    `* ${prof.nome_completo || prof.nome_exibicao || prof.nome}${prof.especialidade ? ` - ${prof.especialidade}` : ''}${prof.cre ? ` (CRE: ${prof.cre})` : ''}${prof.descricao ? `: ${prof.descricao}` : ''}`
  ).join('\n') : 
  (clinicContext.professionals && clinicContext.professionals.length > 0 ? 
    clinicContext.professionals.map(p => `* ${p.nome_exibicao || p.nome_completo || p.nome}`).join('\n') : 
    'N√£o informado'
  )
}

INFORMA√á√ïES ADICIONAIS:
${clinicContext.additionalInfo ? Object.entries(clinicContext.additionalInfo).map(([key, value]) => `- ${key}: ${value}`).join('\n') : 'N√£o dispon√≠vel'}

CONV√äNIOS ACEITOS:
${clinicContext.insurance && clinicContext.insurance.length > 0 ? clinicContext.insurance.map(conv => `* ${conv.nome || conv}`).join('\n') : 'N√£o informado'}

FORMAS DE PAGAMENTO:
${clinicContext.paymentMethods ? Object.entries(clinicContext.paymentMethods).map(([method, details]) => `* ${method}: ${details}`).join('\n') : 'N√£o informado'}

HOR√ÅRIOS DE FUNCIONAMENTO:
${Object.entries(clinicContext.workingHours || {}).map(([day, hours]) => {
  if (hours && hours.abertura && hours.fechamento) {
    return `- ${day}: ${hours.abertura} √†s ${hours.fechamento}`;
  } else if (hours && hours.abertura === null) {
    return `- ${day}: Fechado`;
  } else {
    return `- ${day}: Hor√°rio n√£o configurado`;
  }
}).join('\n')}

COMPORTAMENTO DO AGENTE:
- Proativo: ${agentBehavior.proativo ? 'Sim' : 'N√£o'}
- Oferece sugest√µes: ${agentBehavior.oferece_sugestoes ? 'Sim' : 'N√£o'}
- Solicita feedback: ${agentBehavior.solicita_feedback ? 'Sim' : 'N√£o'}
- Escala√ß√£o autom√°tica: ${agentBehavior.escalacao_automatica ? 'Sim' : 'N√£o'}
- Limite de tentativas: ${agentBehavior.limite_tentativas || 3}

MENSAGENS ESPEC√çFICAS:
- Sauda√ß√£o inicial: "${initialGreeting}" (üîß N√ÉO USE ESTA SAUDA√á√ÉO NAS RESPOSTAS - o sistema aplicar√° automaticamente quando necess√°rio)
- Mensagem de despedida: "${farewellMessage}" (use APENAS quando usu√°rio finalizar conversa)
- üîß CORRE√á√ÉO: Mensagem fora do hor√°rio N√ÉO deve ser inclu√≠da no prompt

EMERG√äNCIAS CARD√çACAS (se configuradas):
${cardiacEmergencies.length > 0 ? cardiacEmergencies.map(emergency => `- ${emergency}`).join('\n') : 'N√£o configuradas'}

EXEMPLOS DE RESPOSTAS CORRETAS:
‚ùå INCORRETO: "Ol√°! Sou o Cardio, assistente virtual da CardioPrime. Como posso ajud√°-lo hoje, Lucas?"
‚úÖ CORRETO: "Ol√° Lucas! √â um prazer atend√™-lo. Como posso auxiliar voc√™ em rela√ß√£o √† sua sa√∫de cardiovascular?"

‚ùå INCORRETO: "Sou o Cardio, assistente virtual da CardioPrime. Como posso ajud√°-lo hoje?"
‚úÖ CORRETO: "Como posso auxiliar voc√™ hoje, Lucas?"

‚úÖ CORRETO: "Ol√° Lucas! Como posso auxiliar voc√™ hoje?"

IMPORTANTE: 
- Sempre mantenha a personalidade e tom de comunica√ß√£o definidos
- üîß SEMPRE use o nome do usu√°rio quando dispon√≠vel
- üîß NUNCA adicione sauda√ß√µes autom√°ticas
- üîß NUNCA seja repetitivo ou autom√°tico
- üîß Mantenha a conversa natural e contextualizada
- üîß Responda diretamente √† pergunta, sem introdu√ß√µes desnecess√°rias
- üîß Responda diretamente √† pergunta, sem introdu√ß√µes desnecess√°rias`;

    return prompt;
  }

  // ‚úÖ CONSTRU√á√ÉO DE MENSAGENS
  static buildMessages(systemPrompt, memory, userMessage) {
    const messages = [
      { role: 'system', content: systemPrompt }
    ];
    
    // Adicionar hist√≥rico de conversa se dispon√≠vel
    if (memory.history && memory.history.length > 0) {
      const recentHistory = memory.history.slice(-5); // √öltimas 5 mensagens
      
      for (const entry of recentHistory) {
        if (entry.user) {
          messages.push({ role: 'user', content: entry.user });
        }
        if (entry.bot) {
          messages.push({ role: 'assistant', content: entry.bot });
        }
      }
    }
    
    // Adicionar mensagem atual do usu√°rio
    messages.push({ role: 'user', content: userMessage });
    
    return messages;
  }

  // ‚úÖ VERIFICA√á√ÉO DE PRIMEIRA CONVERSA DO DIA CORRIGIDA
  static async isFirstConversationOfDay(phoneNumber) {
    try {
      console.log(`üìÖ [LLMOrchestrator] Verificando primeira conversa do dia para: ${phoneNumber}`);
      
      const { data, error } = await supabase
        .from('conversation_memory')
        .select('last_interaction, memory_data')
        .eq('phone_number', phoneNumber)
        .single();
      
      if (error && error.code !== 'PGRST116') {
        console.error('‚ùå [LLMOrchestrator] Erro ao buscar mem√≥ria:', error);
        throw error;
      }
      
      if (!data || !data.last_interaction) {
        console.log('üìÖ [LLMOrchestrator] Primeira conversa - sem hist√≥rico anterior');
        return true; // Primeira conversa
      }
      
      const lastConversation = new Date(data.last_interaction);
      const today = new Date();
      
      // Verificar se √© o mesmo dia (usando timezone do Brasil)
      const lastConversationDate = lastConversation.toLocaleDateString('pt-BR', { timeZone: 'America/Sao_Paulo' });
      const todayDate = today.toLocaleDateString('pt-BR', { timeZone: 'America/Sao_Paulo' });
      
      // üîß CORRE√á√ÉO: L√≥gica estava invertida
      const isFirstOfDay = lastConversationDate !== todayDate;
      
      // üîß CORRE√á√ÉO ADICIONAL: Verificar se h√° conversas no mesmo dia
      let hasConversationToday = false;
      if (data.memory_data && data.memory_data.history) {
        const todayStart = new Date(todayDate);
        todayStart.setHours(0, 0, 0, 0);
        
        hasConversationToday = data.memory_data.history.some(msg => {
          const msgDate = new Date(msg.timestamp);
          return msgDate >= todayStart;
        });
      }
      
      // Se h√° conversas hoje, n√£o √© primeira conversa do dia
      const finalResult = isFirstOfDay && !hasConversationToday;
      
      console.log('üìÖ [LLMOrchestrator] Verifica√ß√£o de primeira conversa:', {
        lastConversation: lastConversationDate,
        today: todayDate,
        isFirstOfDay,
        hasConversationToday,
        finalResult,
        lastInteractionRaw: data.last_interaction,
        lastInteractionDate: lastConversation.toISOString(),
        todayDateRaw: today.toISOString(),
        historyCount: data.memory_data?.history?.length || 0
      });
      
      return finalResult;
      
    } catch (error) {
      console.error('‚ùå [LLMOrchestrator] Erro ao verificar primeira conversa do dia:', error);
      return true; // Em caso de erro, assumir primeira conversa
    }
  }

  // ‚úÖ VERIFICA√á√ÉO DE HOR√ÅRIO DE FUNCIONAMENTO
  static isWithinBusinessHours(clinicContext) {
    try {
      console.log('üïí [LLMOrchestrator] Verificando hor√°rio de funcionamento');
      
      // ‚úÖ PRIORIDADE: Dados do JSON de contextualiza√ß√£o
      if (clinicContext.workingHours && Object.keys(clinicContext.workingHours).length > 0) {
        console.log('üìÑ [LLMOrchestrator] Usando hor√°rios do JSON de contextualiza√ß√£o');
        return this.checkWorkingHours(clinicContext.workingHours);
      }
      
      console.log('‚ö†Ô∏è [LLMOrchestrator] Sem dados de hor√°rio, assumindo aberto');
      return true;
      
    } catch (error) {
      console.error('‚ùå [LLMOrchestrator] Erro ao verificar hor√°rio:', error);
      return true; // Em caso de erro, assumir aberto
    }
  }
  
  /**
   * Verifica hor√°rios do JSON
   */
  static checkWorkingHours(workingHours) {
    // Usar timezone do Brasil para verificar hor√°rio de funcionamento
    const now = new Date();
    const brazilTime = new Date(now.toLocaleString("en-US", {timeZone: "America/Sao_Paulo"}));
    
    console.log('üïí [LLMOrchestrator] Verificando hor√°rio JSON:', {
      utc: now.toISOString(),
      brazil: brazilTime.toLocaleString(),
      brazilHours: brazilTime.getHours(),
      brazilMinutes: brazilTime.getMinutes()
    });
    
    const currentDay = this.getDayOfWeek(brazilTime.getDay());
    const currentTime = brazilTime.getHours() * 100 + brazilTime.getMinutes(); // Formato HHMM

    const todaySchedule = workingHours[currentDay];
    
    if (!todaySchedule || !todaySchedule.abertura || !todaySchedule.fechamento) {
      console.log('üïí [LLMOrchestrator] Fechado - sem hor√°rio configurado para:', currentDay);
      return false; // Fechado se n√£o h√° hor√°rio configurado
    }

    const openingTime = this.parseTime(todaySchedule.abertura);
    const closingTime = this.parseTime(todaySchedule.fechamento);

    const isWithin = currentTime >= openingTime && currentTime <= closingTime;
    
    console.log('üïí [LLMOrchestrator] Resultado JSON:', {
      currentDay,
      currentTime,
      openingTime,
      closingTime,
      isWithin
    });

    return isWithin;
  }

  /**
   * Converte string de tempo para formato HHMM
   */
  static parseTime(timeString) {
    const [hours, minutes] = timeString.split(':').map(Number);
    return hours * 100 + minutes;
  }

  /**
   * Obt√©m o dia da semana em formato string
   */
  static getDayOfWeek(dayNumber) {
    const days = ['domingo', 'segunda', 'terca', 'quarta', 'quinta', 'sexta', 'sabado'];
    return days[dayNumber];
  }

  // ‚úÖ APLICA√á√ÉO DE L√ìGICA DE RESPOSTA CORRIGIDA
  static async applyResponseLogic(response, clinicContext, isFirstConversationOfDay, isWithinBusinessHours, userProfile, conversationHistory) {
    try {
      // Obter configura√ß√µes do agente
      const agentConfig = clinicContext.agentConfig || {};
      
      console.log('üîß [LLMOrchestrator] Aplicando l√≥gica de resposta:', {
        isFirstConversationOfDay,
        isWithinBusinessHours,
        hasUserProfile: !!userProfile?.name,
        agentName: agentConfig.nome || 'Assistente Virtual'
      });
      
      // üîß CORRE√á√ÉO: Se est√° FORA do hor√°rio, usar mensagem fora do hor√°rio
      if (!isWithinBusinessHours) {
        const outOfHoursMessage = agentConfig.mensagem_fora_horario || 
          'No momento estamos fora do hor√°rio de atendimento. Retornaremos seu contato no pr√≥ximo hor√°rio comercial.';
        
        console.log('üïí [LLMOrchestrator] Aplicando mensagem fora do hor√°rio');
        return outOfHoursMessage;
      }
      
      // üîß CORRE√á√ÉO: Se est√° DENTRO do hor√°rio, continuar com a l√≥gica normal
      console.log('‚úÖ [LLMOrchestrator] Dentro do hor√°rio - aplicando l√≥gica normal de resposta');

      let finalResponse = response;

      // üîí SANITIZA√á√ÉO PREVENTIVA (refor√ßada): se o texto indicar "fora do hor√°rio", substituir resposta inteira
      const outOfHoursTrigger = /(fora do hor√°rio|No momento estamos|pr√≥ximo hor√°rio comercial|Retornaremos seu contato)/i;
      if (outOfHoursTrigger.test(finalResponse)) {
        console.log('üßπ [LLMOrchestrator] Detectado padr√£o de "fora do hor√°rio" dentro do expediente - aplicando fallback seguro');
        finalResponse = 'Como posso ajudar?';
      } else {
        // Limpeza adicional de fragmentos residuais
        const outOfHoursPatterns = [
          /fora do hor√°rio de atendimento/gi,
          /estamos fora do hor√°rio/gi,
          /pr√≥ximo hor√°rio comercial/gi,
          /^No momento estamos.*$/gmi,
          /^Retornaremos seu contato.*$/gmi,
          /^Para emerg√™ncias.*$/gmi
        ];
        const sanitized = outOfHoursPatterns.reduce((acc, pattern) => acc.replace(pattern, ''), finalResponse).trim();
        if (sanitized !== finalResponse) {
          console.log('üßπ [LLMOrchestrator] Removidos fragmentos residuais de "fora do hor√°rio"');
          finalResponse = sanitized || 'Como posso ajudar?';
        }
      }

      // üîß CORRE√á√ÉO 1: S√≥ adicionar sauda√ß√£o na PRIMEIRA conversa do dia E se n√£o houve sauda√ß√£o na conversa atual
      if (isFirstConversationOfDay) {
        console.log('üëã [LLMOrchestrator] PRIMEIRA conversa do dia - verificando se j√° houve sauda√ß√£o na conversa atual');
        
        // üîß CORRE√á√ÉO: Verificar m√∫ltiplas estruturas de dados para sauda√ß√£o
        let hasGreetingInConversation = false;
        
        if (conversationHistory && Array.isArray(conversationHistory)) {
          // Estrutura 1: Array com objetos {role, content}
          hasGreetingInConversation = conversationHistory.some(msg => 
            msg.role === 'assistant' && msg.content && (
              msg.content.includes('Ol√°! Sou o') ||
              msg.content.includes('assistente virtual') ||
              msg.content.includes('Como posso ajud√°-lo') ||
              msg.content.includes('Em que posso ajudar') ||
              msg.content.includes('Como posso cuidar') ||
              msg.content.includes('Ol√°.') ||
              msg.content.includes('Sou o Cardio') ||
              msg.content.includes('assistente virtual da CardioPrime')
            )
          );
          
          // Estrutura 2: Array com objetos {bot, user} (estrutura antiga)
          if (!hasGreetingInConversation) {
            hasGreetingInConversation = conversationHistory.some(msg => 
              msg.bot && (
                msg.bot.includes('Ol√°! Sou o') ||
                msg.bot.includes('assistente virtual') ||
                msg.bot.includes('Como posso ajud√°-lo') ||
                msg.bot.includes('Em que posso ajudar') ||
                msg.bot.includes('Como posso cuidar') ||
                msg.bot.includes('Ol√°.') ||
                msg.bot.includes('Sou o Cardio') ||
                msg.bot.includes('assistente virtual da CardioPrime')
              )
            );
          }
        }
        
        console.log('üîç [LLMOrchestrator] Verifica√ß√£o de sauda√ß√£o na conversa:', {
          hasConversationHistory: !!conversationHistory,
          conversationHistoryLength: conversationHistory?.length || 0,
          hasGreetingInConversation,
          conversationHistoryType: conversationHistory ? Array.isArray(conversationHistory) ? 'Array' : typeof conversationHistory : 'null',
          conversationHistory: conversationHistory?.slice(0, 3).map(msg => ({
            role: msg.role || 'unknown',
            bot: msg.bot ? 'present' : 'absent',
            content: msg.content ? msg.content.substring(0, 100) + '...' : 'absent',
            keys: Object.keys(msg || {})
          }))
        });
        
        if (hasGreetingInConversation) {
          console.log('üëã [LLMOrchestrator] J√° houve sauda√ß√£o na conversa atual - n√£o adicionar nova');
          return response; // Retornar resposta sem sauda√ß√£o
        }
        
        console.log('üëã [LLMOrchestrator] Aplicando sauda√ß√£o inicial');
        
        const initialGreeting = agentConfig.saudacao_inicial || 
          `Ol√°! Sou o ${agentConfig.nome || 'Assistente Virtual'}, assistente virtual da ${clinicContext.name}. Como posso ajud√°-lo hoje?`;
        
        // Personalizar sauda√ß√£o com nome do usu√°rio se dispon√≠vel
        let personalizedGreeting = initialGreeting;
        if (userProfile?.name) {
          personalizedGreeting = initialGreeting.replace('Como posso ajud√°-lo hoje?', `Como posso ajud√°-lo hoje, ${userProfile.name}?`);
          console.log(`üë§ [LLMOrchestrator] Sauda√ß√£o personalizada para: ${userProfile.name}`);
        }
        
        // Verificar se j√° tem sauda√ß√£o na resposta do LLM
        const hasGreeting = response.includes('Ol√°! Sou o') || 
                           response.includes('assistente virtual') ||
                           response.includes('Como posso ajud√°-lo') ||
                           response.includes('Em que posso ajudar') ||
                           response.includes('Como posso cuidar') ||
                           response.includes('Ol√°.') ||
                           response.includes('Sou o Cardio') ||
                           response.includes('assistente virtual da CardioPrime');
        
        console.log('üîç [LLMOrchestrator] Verificando duplica√ß√£o de sauda√ß√£o:', hasGreeting ? 'ENCONTRADA' : 'N√ÉO ENCONTRADA');
        
        if (hasGreeting) {
          // Remover sauda√ß√µes duplicadas da resposta
          const cleanResponse = this.removeGreetingPatterns(response);
          console.log('üßπ [LLMOrchestrator] Sauda√ß√£o duplicada removida da resposta');
          finalResponse = personalizedGreeting + "\n\n" + cleanResponse;
        } else {
          // N√£o tem sauda√ß√£o, adicionar normalmente
          finalResponse = personalizedGreeting + "\n\n" + response;
        }
      } else {
        console.log('üìÖ [LLMOrchestrator] N√ÉO √© primeira conversa do dia - sem sauda√ß√£o');
      }

      // üîß CORRE√á√ÉO 2: N√ÉO adicionar mensagem de despedida automaticamente
      console.log('üîß [LLMOrchestrator] Mensagem de despedida n√£o ser√° adicionada automaticamente');

      // üîß NOVA CORRE√á√ÉO: APLICAR CORRE√á√ÉO AUTOM√ÅTICA DE FORMATA√á√ÉO PARA TODAS AS CL√çNICAS
      console.log('üîß [LLMOrchestrator] Aplicando corre√ß√£o autom√°tica de formata√ß√£o');
      const { normalizeMessage } = await import('../utils/messageNormalization.js');
      const formattedResponse = normalizeMessage(finalResponse);
      if (formattedResponse !== finalResponse) {
        console.log('‚úÖ [LLMOrchestrator] Formata√ß√£o corrigida automaticamente');
        finalResponse = formattedResponse;
      }

      // Para todas as respostas, verificar duplica√ß√µes gerais
      // Removendo desduplica√ß√£o espec√≠fica por enquanto; manteremos normaliza√ß√£o gen√©rica
      const cleanedResponse = finalResponse;
      if (cleanedResponse !== finalResponse) {
        console.log('üßπ [LLMOrchestrator] Conte√∫do duplicado removido da resposta');
      }

      console.log('‚úÖ [LLMOrchestrator] L√≥gica de resposta aplicada com sucesso');
      return cleanedResponse;
      
    } catch (error) {
      console.error('‚ùå [LLMOrchestrator] Erro ao aplicar l√≥gica de resposta:', error);
      return response;
    }
  }

  // ‚úÖ REMO√á√ÉO DE PADR√ïES DE SAUDA√á√ÉO DUPLICADOS MELHORADA
  static removeGreetingPatterns(text) {
    console.log('üßπ [LLMOrchestrator] Removendo padr√µes de sauda√ß√£o do texto');
    
    const patterns = [
      // Padr√µes gen√©ricos
      /Ol√°! Sou o .*?assistente virtual.*?Como posso ajud√°-lo hoje\?/gi,
      /Ol√°! Sou o .*?assistente virtual.*?Em que posso ajudar/gi,
      /Ol√°! Sou o .*?assistente virtual.*?Como posso cuidar/gi,
      /Ol√°! Sou o .*?assistente virtual.*?Como posso ajud√°-lo/gi,
      /Ol√°! Sou o .*?assistente virtual.*?Em que posso ajud√°-lo/gi,
      /Ol√°! Sou o .*?assistente virtual.*?Como posso ajudar/gi,
      
      // Padr√µes espec√≠ficos da CardioPrime (exatos da conversa)
      /Ol√°\.\s*\n\s*Sou o Cardio, assistente virtual da CardioPrime\.\s*\n\s*Como posso cuidar da sua sa√∫de cardiovascular hoje\./gi,
      /Ol√°\.\s*\n\s*Sou o Cardio, assistente virtual da CardioPrime\.\s*\n\s*Como posso ajud√°-lo hoje\./gi,
      /Ol√°\.\s*\n\s*Sou o Cardio, assistente virtual da CardioPrime\.\s*\n\s*Em que posso ajudar voc√™ hoje\?/gi,
      
      // Padr√µes mais flex√≠veis da CardioPrime
      /Ol√°\.\s*\n\s*Sou o Cardio.*?assistente virtual da CardioPrime.*?Como posso cuidar da sua sa√∫de cardiovascular hoje/gi,
      /Ol√°\.\s*\n\s*Sou o Cardio.*?assistente virtual da CardioPrime.*?Como posso ajud√°-lo hoje/gi,
      
      // Padr√µes espec√≠ficos da ESADI
      /Ol√°! Sou a Jessica, assistente virtual da ESADI\. Estou aqui para ajud√°-lo com agendamentos e orienta√ß√µes sobre exames\. Como posso ajud√°-lo hoje\?/gi,
      
      // Padr√µes gen√©ricos de in√≠cio
      /^Ol√°\.?\s*\n?/gi,
      /^Oi\.?\s*\n?/gi,
      /^Ol√°!?\s*\n?/gi,
      /^Oi!?\s*\n?/gi,
      
      // Padr√µes espec√≠ficos de sauda√ß√£o repetitiva
      /Ol√°\.\s*\n\s*Sou o .*?assistente virtual da .*?Como posso cuidar da sua sa√∫de cardiovascular hoje\./gi,
      /Ol√°\.\s*\n\s*Sou o .*?assistente virtual da .*?Como posso ajud√°-lo hoje\./gi
    ];
    
    let cleanText = text;
    patterns.forEach(pattern => {
      cleanText = cleanText.replace(pattern, '');
    });
    
    // Limpar espa√ßos extras e quebras de linha duplicadas
    cleanText = cleanText.replace(/\n\s*\n/g, '\n\n').trim();
    
    // Remover frases soltas que podem ter ficado
    cleanText = cleanText.replace(/^voc√™ hoje\?\s*/gi, '');
    cleanText = cleanText.replace(/^Em que posso ajudar\s*/gi, '');
    cleanText = cleanText.replace(/^Como posso ajud√°-lo\s*/gi, '');
    
    return cleanText;
  }

  // üîß NOVA FUN√á√ÉO: CORRE√á√ÉO AUTOM√ÅTICA DE FORMATA√á√ÉO PARA TODAS AS CL√çNICAS
  static fixMessageFormatting(text) {
    console.log('üîß [LLMOrchestrator] Aplicando corre√ß√£o autom√°tica de formata√ß√£o');
    
    if (!text || typeof text !== 'string') {
      return text;
    }
    
    let cleaned = text;
    
    // 1. Remover caracteres especiais problem√°ticos (‚Å†, etc.)
    cleaned = cleaned.replace(/[‚Å†]/g, '');
    
    // üöÄ SOLU√á√ÉO ULTIMATE: Substitui√ß√µes diretas e espec√≠ficas
    // Corrigir os problemas espec√≠ficos identificados pelo usu√°rio
    
    // Problema 1: "*Dr.\n\nRoberto Silva*" ‚Üí "*Dr. Roberto Silva*"
    cleaned = cleaned.replace(/\*\s*Dr\.\s*\n+\s*Roberto Silva\*/g, '*Dr. Roberto Silva*');
    
    // Problema 2: "*Dra.\n\nMaria Fernanda*" ‚Üí "*Dra. Maria Fernanda*"
    cleaned = cleaned.replace(/\*\s*Dra\.\s*\n+\s*Maria Fernanda\*/g, '*Dra. Maria Fernanda*');
    
    // Problema 3: "- *Dr.\n\nRoberto Silva*:" ‚Üí "- *Dr. Roberto Silva*:"
    cleaned = cleaned.replace(/-\s*\*\s*Dr\.\s*\n+\s*Roberto Silva\*:/g, '- *Dr. Roberto Silva*:');
    
    // Problema 4: "- *Dra.\n\nMaria Fernanda*:" ‚Üí "- *Dra. Maria Fernanda*:"
    cleaned = cleaned.replace(/-\s*\*\s*Dra\.\s*\n+\s*Maria Fernanda\*:/g, '- *Dra. Maria Fernanda*:');
    
    // üöÄ SOLU√á√ÉO ULTIMATE: Adicionar quebras de linha adequadas
    
    // T√≠tulo: "conta com os seguintes m√©dicos:" ‚Üí "conta com os seguintes m√©dicos:\n\n"
    cleaned = cleaned.replace(/(conta com os seguintes m√©dicos:)/g, '$1\n\n');
    cleaned = cleaned.replace(/(conta com os seguintes profissionais:)/g, '$1\n\n');
    cleaned = cleaned.replace(/(contamos com dois profissionais especializados em cardiologia:)/g, '$1\n\n');
    cleaned = cleaned.replace(/(oferece os seguintes exames:)/g, '$1\n\n');
    
    // Conclus√£o: "Ambos s√£o dedicados" ‚Üí "\n\nAmbos s√£o dedicados"
    cleaned = cleaned.replace(/(Ambos s√£o dedicados)/g, '\n\n$1');
    cleaned = cleaned.replace(/(Esses exames s√£o essenciais)/g, '\n\n$1');
    cleaned = cleaned.replace(/(Ambos est√£o dispon√≠veis)/g, '\n\n$1');
    
    // A√ß√£o: "Caso precise de mais informa√ß√µes" ‚Üí "\n\nCaso precise de mais informa√ß√µes"
    cleaned = cleaned.replace(/(Caso precise de mais informa√ß√µes)/gi, '\n\n$1');
    cleaned = cleaned.replace(/(Se precisar de mais informa√ß√µes)/gi, '\n\n$1');
    cleaned = cleaned.replace(/(Caso tenha interesse)/gi, '\n\n$1');
    cleaned = cleaned.replace(/(Se precisar agendar)/gi, '\n\n$1');
    
    // 2. Corrigir espa√ßamento ap√≥s n√∫meros em listas (se houver)
    cleaned = cleaned.replace(/(\d+\.)\s*‚Å†\s*‚Å†/gi, '$1 ');
    
    // 3. Separar itens de lista que est√£o juntos (se houver)
    cleaned = cleaned.replace(/(\d+\.\s*[^:]+:\s*[^.]+\.)\s*(\d+\.)/gi, '$1\n$2');
    
    // 4. Adicionar quebras de linha ap√≥s cada item de lista (se houver)
    cleaned = cleaned.replace(/(\d+\.\s*[^:]+:\s*[^.]+\.)/gi, '$1\n');
    
    // üöÄ SOLU√á√ÉO ULTIMATE: Limpeza final
    
    // Normalizar quebras de linha (m√°ximo 2 consecutivas)
    cleaned = cleaned.replace(/\n{3,}/g, '\n\n');
    
    // Limpar espa√ßos m√∫ltiplos APENAS entre palavras (n√£o quebras de linha)
    cleaned = cleaned.replace(/[ ]+/g, ' ');
    
    // Remover quebras de linha extras no final
    cleaned = cleaned.replace(/\n+$/, '');
  
    // Normalizar quebras de linha finais
    cleaned = cleaned.replace(/\n\s*\n/g, '\n\n');
    
    console.log('‚úÖ [LLMOrchestrator] Formata√ß√£o corrigida automaticamente');
    return cleaned.trim();
  }

  // ‚úÖ REMO√á√ÉO DE CONTE√öDO DUPLICADO
  static removeDuplicateContent(text) {
    // Dividir o texto em frases
    const sentences = text.split(/[.!?]+/).filter(s => s.trim().length > 0);
    
    // Array para armazenar frases √∫nicas
    const uniqueSentences = [];
    const seenPhrases = new Set();
    
    for (const sentence of sentences) {
      const cleanSentence = sentence.trim();
      if (cleanSentence.length === 0) continue;
      
      // Verificar se a frase √© muito similar a uma j√° vista
      let isDuplicate = false;
      for (const seenPhrase of seenPhrases) {
        if (this.calculateSimilarity(cleanSentence, seenPhrase) > 0.8) {
          isDuplicate = true;
          break;
        }
      }
      
      if (!isDuplicate) {
        uniqueSentences.push(cleanSentence);
        seenPhrases.add(cleanSentence);
      }
    }
    
    return uniqueSentences.join('. ') + (uniqueSentences.length > 0 ? '.' : '');
  }

  // ‚úÖ C√ÅLCULO DE SIMILARIDADE ENTRE FRASES
  static calculateSimilarity(str1, str2) {
    const words1 = str1.toLowerCase().split(/\s+/);
    const words2 = str2.toLowerCase().split(/\s+/);
    
    const commonWords = words1.filter(word => words2.includes(word));
    const totalWords = new Set([...words1, ...words2]);
    
    return commonWords.length / totalWords.size;
  }

  // ‚úÖ GERA√á√ÉO DE FALLBACK INTELIGENTE
  static generateIntelligentFallbackResponse(intent, clinicContext, isFirstConversationOfDay, isWithinBusinessHours, userProfile, originalMessage) {
    const agentConfig = clinicContext.agentConfig || {};
    const agentName = agentConfig.nome || 'Assistente Virtual';
    
    if (!isWithinBusinessHours) {
      return agentConfig.mensagem_fora_horario || 
        'No momento estamos fora do hor√°rio de atendimento. Retornaremos seu contato no pr√≥ximo hor√°rio comercial.';
    }
    
    if (isFirstConversationOfDay) {
      const greeting = agentConfig.saudacao_inicial || 
        `Ol√°! Sou o ${agentName}, assistente virtual da ${clinicContext.name}. Como posso ajud√°-lo hoje?`;
      
      if (userProfile?.name) {
        return greeting.replace('Como posso ajud√°-lo hoje?', `Como posso ajud√°-lo hoje, ${userProfile.name}?`);
      }
      return greeting;
    }
    
    // Fallback gen√©rico
    return `Desculpe, n√£o consegui processar sua mensagem. Como posso ajud√°-lo, ${userProfile?.name || 'senhor(a)'}?`;
  }
}

export { LLMOrchestratorService };
