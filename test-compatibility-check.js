/**
 * TESTE DE COMPATIBILIDADE - VERIFICA√á√ÉO DE IMPACTOS DA ATUALIZA√á√ÉO
 */

import dotenv from 'dotenv';

// Carregar vari√°veis de ambiente
dotenv.config();

console.log('üîç TESTE DE COMPATIBILIDADE - VERIFICA√á√ÉO DE IMPACTOS');
console.log('=' .repeat(80));

class CompatibilityCheckTest {
  constructor() {
    this.testResults = [];
    this.warnings = [];
    this.errors = [];
  }

  /**
   * Executa verifica√ß√£o de compatibilidade
   */
  async runCompatibilityCheck() {
    try {
      // Teste 1: Verificar compatibilidade de inten√ß√µes
      await this.testIntentCompatibility();
      
      // Teste 2: Verificar fluxo de agendamento
      await this.testAppointmentFlowCompatibility();
      
      // Teste 3: Verificar outras funcionalidades
      await this.testOtherFunctionalitiesCompatibility();
      
      // Teste 4: Verificar fallback system
      await this.testFallbackCompatibility();
      
      // Relat√≥rio final
      this.generateCompatibilityReport();
      
    } catch (error) {
      console.error('üí• ERRO NO TESTE DE COMPATIBILIDADE:', error);
      this.errors.push({
        test: 'EXECU√á√ÉO_PRINCIPAL',
        error: error.message
      });
      this.generateCompatibilityReport();
    }
  }

  /**
   * Teste 1: Verificar compatibilidade de inten√ß√µes
   */
  async testIntentCompatibility() {
    console.log('\nüîç TESTE 1: COMPATIBILIDADE DE INTEN√á√ïES');
    console.log('-'.repeat(50));
    
    try {
      // Importar LLMOrchestratorService
      const { LLMOrchestratorService } = await import('./services/core/index.js');
      
      // Testar inten√ß√µes antigas (deve continuar funcionando)
      const oldIntentMessages = [
        'oi',
        'bom dia',
        'agendar consulta',
        'marcar hor√°rio'
      ];
      
      for (const message of oldIntentMessages) {
        console.log(`üì± Testando inten√ß√£o antiga: "${message}"`);
        
        try {
          const intent = await LLMOrchestratorService.detectIntent(message);
          
          if (!intent || !intent.name) {
            throw new Error(`Detec√ß√£o falhou para mensagem antiga`);
          }
          
          console.log(`   ‚úÖ Inten√ß√£o: ${intent.name} (confian√ßa: ${intent.confidence})`);
          
          // Verificar se ainda √© reconhecida como inten√ß√£o de agendamento (se aplic√°vel)
          if (message.includes('agendar') || message.includes('marcar')) {
            const isAppointmentIntent = LLMOrchestratorService.isAppointmentIntent(intent);
            if (isAppointmentIntent) {
              console.log(`   ‚úÖ Ainda reconhecida como inten√ß√£o de agendamento`);
            } else {
              console.log(`   ‚ö†Ô∏è Mudan√ßa de comportamento: n√£o √© mais reconhecida como agendamento`);
              this.warnings.push({
                test: 'INTENT_COMPATIBILITY',
                warning: `Mensagem "${message}" mudou de comportamento`
              });
            }
          }
          
        } catch (error) {
          console.log(`   ‚ùå Erro na detec√ß√£o: ${error.message}`);
          this.errors.push({
            test: 'INTENT_COMPATIBILITY',
            error: `Falha na detec√ß√£o de mensagem antiga: "${message}"`
          });
        }
      }
      
      this.testResults.push({ test: 'INTENT_COMPATIBILITY', status: 'PASS' });
      console.log('‚úÖ Compatibilidade de inten√ß√µes mantida');
      
    } catch (error) {
      console.error(`‚ùå ${error.message}`);
      this.errors.push({ test: 'INTENT_COMPATIBILITY', error: error.message });
    }
  }

  /**
   * Teste 2: Verificar fluxo de agendamento
   */
  async testAppointmentFlowCompatibility() {
    console.log('\nüìÖ TESTE 2: COMPATIBILIDADE DO FLUXO DE AGENDAMENTO');
    console.log('-'.repeat(50));
    
    try {
      // Importar servi√ßos
      const { AppointmentFlowManager, ClinicContextManager } = await import('./services/core/index.js');
      
      // Verificar se todas as inten√ß√µes s√£o suportadas
      const supportedIntents = [
        'APPOINTMENT_CREATE',
        'APPOINTMENT_SCHEDULE', 
        'APPOINTMENT_RESCHEDULE',
        'APPOINTMENT_CANCEL',
        'APPOINTMENT_LIST',
        'APPOINTMENT_CHECK'
      ];
      
      console.log('üîç Verificando suporte a inten√ß√µes no AppointmentFlowManager...');
      
      for (const intentName of supportedIntents) {
        const intent = { name: intentName, confidence: 0.9 };
        const isSupported = AppointmentFlowManager.prototype.isAppointmentIntent ? 
          AppointmentFlowManager.prototype.isAppointmentIntent(intent) :
          true; // Se n√£o h√° m√©todo espec√≠fico, assumir suporte
        
        if (isSupported) {
          console.log(`   ‚úÖ ${intentName} - Suportado`);
        } else {
          console.log(`   ‚ùå ${intentName} - N√ÉO suportado`);
          this.errors.push({
            test: 'APPOINTMENT_FLOW_COMPATIBILITY',
            error: `Inten√ß√£o ${intentName} n√£o √© suportada no fluxo`
          });
        }
      }
      
      this.testResults.push({ test: 'APPOINTMENT_FLOW_COMPATIBILITY', status: 'PASS' });
      console.log('‚úÖ Fluxo de agendamento compat√≠vel');
      
    } catch (error) {
      console.error(`‚ùå ${error.message}`);
      this.errors.push({ test: 'APPOINTMENT_FLOW_COMPATIBILITY', error: error.message });
    }
  }

  /**
   * Teste 3: Verificar outras funcionalidades
   */
  async testOtherFunctionalitiesCompatibility() {
    console.log('\nüîß TESTE 3: COMPATIBILIDADE DE OUTRAS FUNCIONALIDADES');
    console.log('-'.repeat(50));
    
    try {
      // Importar LLMOrchestratorService
      const { LLMOrchestratorService } = await import('./services/core/index.js');
      
      // Verificar se fun√ß√µes essenciais ainda existem
      const essentialFunctions = [
        'detectIntent',
        'isAppointmentIntent', 
        'mapIntentToCategory',
        'prepareSystemPrompt',
        'buildMessages',
        'isWithinBusinessHours'
      ];
      
      console.log('üîç Verificando fun√ß√µes essenciais...');
      
      for (const funcName of essentialFunctions) {
        if (typeof LLMOrchestratorService[funcName] === 'function') {
          console.log(`   ‚úÖ ${funcName} - Dispon√≠vel`);
        } else {
          console.log(`   ‚ùå ${funcName} - N√ÉO dispon√≠vel`);
          this.errors.push({
            test: 'OTHER_FUNCTIONALITIES_COMPATIBILITY',
            error: `Fun√ß√£o essencial ${funcName} n√£o est√° dispon√≠vel`
          });
        }
      }
      
      // Verificar se estrutura de retorno √© compat√≠vel
      console.log('\nüîç Verificando estrutura de retorno...');
      
      try {
        const testIntent = await LLMOrchestratorService.detectIntent('oi');
        
        if (testIntent && typeof testIntent === 'object') {
          const hasRequiredProps = ['name', 'confidence'].every(prop => prop in testIntent);
          
          if (hasRequiredProps) {
            console.log('   ‚úÖ Estrutura de retorno compat√≠vel');
          } else {
            console.log('   ‚ùå Estrutura de retorno incompat√≠vel');
            this.errors.push({
              test: 'OTHER_FUNCTIONALITIES_COMPATIBILITY',
              error: 'Estrutura de retorno da detec√ß√£o de inten√ß√£o incompat√≠vel'
            });
          }
        } else {
          console.log('   ‚ùå Retorno inv√°lido da detec√ß√£o de inten√ß√£o');
          this.errors.push({
            test: 'OTHER_FUNCTIONALITIES_COMPATIBILITY',
            error: 'Retorno inv√°lido da detec√ß√£o de inten√ß√£o'
          });
        }
      } catch (error) {
        console.log(`   ‚ùå Erro ao testar estrutura: ${error.message}`);
        this.errors.push({
          test: 'OTHER_FUNCTIONALITIES_COMPATIBILITY',
          error: `Erro ao testar estrutura: ${error.message}`
        });
      }
      
      this.testResults.push({ test: 'OTHER_FUNCTIONALITIES_COMPATIBILITY', status: 'PASS' });
      console.log('‚úÖ Outras funcionalidades compat√≠veis');
      
    } catch (error) {
      console.error(`‚ùå ${error.message}`);
      this.errors.push({ test: 'OTHER_FUNCTIONALITIES_COMPATIBILITY', error: error.message });
    }
  }

  /**
   * Teste 4: Verificar sistema de fallback
   */
  async testFallbackCompatibility() {
    console.log('\nüîÑ TESTE 4: COMPATIBILIDADE DO SISTEMA DE FALLBACK');
    console.log('-'.repeat(50));
    
    try {
      // Importar LLMOrchestratorService
      const { LLMOrchestratorService } = await import('./services/core/index.js');
      
      // Verificar se fun√ß√£o de fallback existe
      if (typeof LLMOrchestratorService.fallbackIntentRecognition === 'function') {
        console.log('‚úÖ Fun√ß√£o de fallback dispon√≠vel');
        
        // Testar fallback com mensagem simples
        try {
          const fallbackResult = LLMOrchestratorService.fallbackIntentRecognition('oi');
          
          if (fallbackResult && fallbackResult.name) {
            console.log(`   ‚úÖ Fallback funcionando: ${fallbackResult.name}`);
          } else {
            console.log('   ‚ùå Fallback retornou resultado inv√°lido');
            this.errors.push({
              test: 'FALLBACK_COMPATIBILITY',
              error: 'Fallback retornou resultado inv√°lido'
            });
          }
        } catch (error) {
          console.log(`   ‚ùå Erro no fallback: ${error.message}`);
          this.errors.push({
            test: 'FALLBACK_COMPATIBILITY',
            error: `Erro no fallback: ${error.message}`
          });
        }
      } else {
        console.log('‚ùå Fun√ß√£o de fallback n√£o encontrada');
        this.errors.push({
          test: 'FALLBACK_COMPATIBILITY',
          error: 'Fun√ß√£o fallbackIntentRecognition n√£o implementada'
        });
      }
      
      this.testResults.push({ test: 'FALLBACK_COMPATIBILITY', status: 'PASS' });
      console.log('‚úÖ Sistema de fallback compat√≠vel');
      
    } catch (error) {
      console.error(`‚ùå ${error.message}`);
      this.errors.push({ test: 'FALLBACK_COMPATIBILITY', error: error.message });
    }
  }

  /**
   * Gera relat√≥rio final de compatibilidade
   */
  generateCompatibilityReport() {
    console.log('\n' + '='.repeat(80));
    console.log('üìä RELAT√ìRIO FINAL DE COMPATIBILIDADE');
    console.log('='.repeat(80));
    
    const totalTests = this.testResults.length;
    const passedTests = this.testResults.filter(r => r.status === 'PASS').length;
    const failedTests = this.errors.length;
    const warningsCount = this.warnings.length;
    
    console.log(`\nüìà RESUMO DA COMPATIBILIDADE:`);
    console.log(`   ‚úÖ Testes aprovados: ${passedTests}/${totalTests}`);
    console.log(`   ‚ùå Testes falharam: ${failedTests}`);
    console.log(`   ‚ö†Ô∏è Avisos: ${warningsCount}`);
    
    if (this.warnings.length > 0) {
      console.log(`\n‚ö†Ô∏è AVISOS DE COMPATIBILIDADE:`);
      this.warnings.forEach((warning, index) => {
        console.log(`   ${index + 1}. [${warning.test}] ${warning.warning}`);
      });
    }
    
    if (this.errors.length > 0) {
      console.log(`\n‚ùå PROBLEMAS DE COMPATIBILIDADE:`);
      this.errors.forEach((error, index) => {
        console.log(`   ${index + 1}. [${error.test}] ${error.error}`);
      });
    }
    
    if (failedTests === 0 && warningsCount === 0) {
      console.log(`\nüéâ COMPATIBILIDADE TOTAL! Nenhuma funcionalidade ser√° quebrada.`);
      console.log(`\nüí° BENEF√çCIOS DA ATUALIZA√á√ÉO:`);
      console.log(`   ‚úÖ Sistema mais inteligente`);
      console.log(`   ‚úÖ Melhor detec√ß√£o de inten√ß√µes`);
      console.log(`   ‚úÖ Funcionalidades existentes preservadas`);
      console.log(`   ‚úÖ Fallback robusto mantido`);
    } else if (failedTests === 0) {
      console.log(`\n‚úÖ COMPATIBILIDADE B√ÅSICA! Funcionalidades principais preservadas.`);
      console.log(`\n‚ö†Ô∏è ATEN√á√ÉO: Alguns comportamentos podem ter mudado sutilmente.`);
    } else {
      console.log(`\nüö® PROBLEMAS DE COMPATIBILIDADE! Corrija antes de prosseguir.`);
      process.exit(1);
    }
  }
}

// Executar teste
const tester = new CompatibilityCheckTest();
tester.runCompatibilityCheck().catch(error => {
  console.error('üí• ERRO FATAL NO TESTE DE COMPATIBILIDADE:', error);
  process.exit(1);
});
