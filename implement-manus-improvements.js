const { createClient } = require('@supabase/supabase-js');
require('dotenv').config();

// Configurar Supabase
const supabase = createClient(
  'https://niakqdolcdwxtrkbqmdi.supabase.co',
  'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6Im5pYWtxZG9sY2R3eHRya2JxbWRpIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTAxODI1NTksImV4cCI6MjA2NTc1ODU1OX0.90ihAk2geP1JoHIvMj_pxeoMe6dwRwH-rBbJwbFeomw'
);

async function implementManusImprovements() {
  try {
    console.log('üöÄ IMPLEMENTANDO MELHORIAS BASEADAS NA AN√ÅLISE DO MANUS');
    console.log('========================================================');

    // 1. VERIFICAR SISTEMA ATUAL
    console.log('\n1Ô∏è‚É£ Verificando sistema atual...');
    
    const { data: clinicData, error: clinicError } = await supabase
      .from('clinics')
      .select('*')
      .eq('whatsapp_phone', '554730915628')
      .single();

    if (clinicError) {
      console.error('‚ùå Erro ao buscar cl√≠nica:', clinicError);
    } else {
      console.log('‚úÖ Cl√≠nica encontrada:', clinicData.name);
      console.log('üéØ Tem contextualiza√ß√£o:', clinicData.has_contextualization);
    }

    // 2. TESTAR FUN√á√ÉO GET_CLINIC_CONTEXTUALIZATION
    console.log('\n2Ô∏è‚É£ Testando fun√ß√£o get_clinic_contextualization...');
    
    try {
      const { data: contextData, error: contextError } = await supabase.rpc('get_clinic_contextualization', {
        p_whatsapp_phone: '554730915628'
      });

      if (contextError) {
        console.error('‚ùå Erro na fun√ß√£o get_clinic_contextualization:', contextError);
      } else {
        console.log('‚úÖ Fun√ß√£o funcionando!');
        console.log('üìã Dados retornados:', contextData);
      }
    } catch (e) {
      console.log('‚ö†Ô∏è Fun√ß√£o ainda n√£o dispon√≠vel');
    }

    // 3. VERIFICAR TABELAS DE MEM√ìRIA
    console.log('\n3Ô∏è‚É£ Verificando tabelas de mem√≥ria...');
    
    const { data: memoryData, error: memoryError } = await supabase
      .from('conversation_memory')
      .select('*')
      .limit(1);

    if (memoryError) {
      console.error('‚ùå Erro na tabela conversation_memory:', memoryError);
    } else {
      console.log('‚úÖ Tabela conversation_memory funcionando!');
    }

    const { data: messagesData, error: messagesError } = await supabase
      .from('ai_whatsapp_messages')
      .select('*')
      .limit(1);

    if (messagesError) {
      console.error('‚ùå Erro na tabela ai_whatsapp_messages:', messagesError);
    } else {
      console.log('‚úÖ Tabela ai_whatsapp_messages funcionando!');
    }

    // 4. CRIAR ENHANCED AI SERVICE (SE N√ÉO EXISTIR)
    console.log('\n4Ô∏è‚É£ Criando EnhancedAIService...');
    
    const enhancedAIServiceCode = `
const { createClient } = require('@supabase/supabase-js');
const OpenAI = require('openai');
const ConversationMemoryService = require('./conversationMemoryService');
const IntentRecognitionService = require('./intentRecognitionService');

const supabase = createClient(
  process.env.SUPABASE_URL,
  process.env.SUPABASE_ANON_KEY
);

const openai = new OpenAI({
  apiKey: process.env.OPENAI_API_KEY,
});

class EnhancedAIService {
  constructor() {
    this.maxTokens = 1500;
    this.maxHistoryTurns = 12;
    this.temperature = 0.7;
  }

  async processMessage(message, phoneNumber, agentId, context = {}) {
    try {
      console.log('üß† [EnhancedAI] Processando mensagem com IA AVAN√áADA', { phoneNumber, agentId });

      // 1. Carregar mem√≥ria da conversa
      const conversationMemory = await this.loadConversationMemory(phoneNumber, agentId);
      
      // 2. Detectar inten√ß√£o da mensagem
      const intentResult = await this.detectIntent(message, conversationMemory);
      
      // 3. Verificar se √© uma sauda√ß√£o repetida
      const isRepeatedGreeting = this.isRepeatedGreeting(message, conversationMemory);
      
      // 4. Extrair nome do usu√°rio se presente
      const userName = this.extractUserName(message, conversationMemory);
      if (userName && !conversationMemory.userName) {
        conversationMemory.userName = userName;
      }
      
      // 5. Detectar a√ß√µes pendentes
      const pendingAction = this.detectPendingAction(conversationMemory);
      
      // 6. Verificar se √© retorno do usu√°rio
      const isUserReturn = this.isUserReturn(conversationMemory);
      
      // 7. Gerar resposta contextualizada
      const response = await this.generateContextualResponse({
        message,
        phoneNumber,
        agentId,
        context,
        conversationMemory,
        intentResult,
        isRepeatedGreeting,
        userName: conversationMemory.userName,
        pendingAction,
        isUserReturn
      });
      
      // 8. Salvar intera√ß√£o na mem√≥ria
      await this.saveConversationMemory(phoneNumber, agentId, {
        userMessage: message,
        botResponse: response,
        intent: intentResult.intent,
        confidence: intentResult.confidence,
        userName: conversationMemory.userName,
        pendingAction: pendingAction,
        isUserReturn: isUserReturn,
        timestamp: new Date().toISOString()
      });
      
      return {
        success: true,
        response: response,
        intent: intentResult.intent,
        confidence: intentResult.confidence,
        metadata: {
          userName: conversationMemory.userName,
          pendingAction: pendingAction,
          isUserReturn: isUserReturn,
          isRepeatedGreeting: isRepeatedGreeting
        }
      };

    } catch (error) {
      console.error('‚ùå [EnhancedAI] Erro no processamento:', error);
      return {
        success: false,
        response: 'Desculpe, estou com dificuldades t√©cnicas. Tente novamente em alguns instantes.',
        error: error.message
      };
    }
  }

  async detectIntent(message, conversationMemory) {
    try {
      const prompt = \`Analise a mensagem e classifique a inten√ß√£o principal.

Mensagem: "\${message}"

Hist√≥rico recente: \${JSON.stringify(conversationMemory.recentMessages || [])}

Inten√ß√µes poss√≠veis:
- GREETING: Sauda√ß√µes (ol√°, oi, bom dia, etc.)
- APPOINTMENT_REQUEST: Solicita√ß√£o de agendamento
- CLINIC_INFO: Informa√ß√µes gerais da cl√≠nica
- DOCTOR_INFO: Informa√ß√µes sobre m√©dicos
- SCHEDULE_INFO: Hor√°rios de funcionamento
- PRICE_INFO: Informa√ß√µes sobre pre√ßos/valores
- LOCATION_INFO: Localiza√ß√£o da cl√≠nica
- ABOUT_BOT: Perguntas sobre o assistente/capacidades
- HELP: Pedidos de ajuda
- CONTINUE_ACTION: Continuar a√ß√£o anterior
- GOODBYE: Despedidas
- OTHER: Outras inten√ß√µes

Responda apenas com o nome da inten√ß√£o e um score de confian√ßa (0-1).
Formato: INTEN√á√ÉO|CONFIAN√áA\`;

      const completion = await openai.chat.completions.create({
        model: "gpt-4o-mini",
        messages: [{ role: "user", content: prompt }],
        max_tokens: 50,
        temperature: 0.3
      });

      const result = completion.choices[0].message.content.trim();
      const [intent, confidence] = result.split('|');

      return {
        intent: intent || 'OTHER',
        confidence: parseFloat(confidence) || 0.5
      };

    } catch (error) {
      console.error('‚ùå [EnhancedAI] Erro na detec√ß√£o de inten√ß√£o:', error);
      return { intent: 'OTHER', confidence: 0.5 };
    }
  }

  async generateContextualResponse(params) {
    const {
      message,
      context,
      conversationMemory,
      intentResult,
      isRepeatedGreeting,
      userName,
      pendingAction,
      isUserReturn
    } = params;

    try {
      // Construir prompt contextualizado
      let systemPrompt = context.systemPrompt || \`Voc√™ √© um assistente virtual de uma cl√≠nica m√©dica.
        Seja acolhedor, profissional e √∫til. Use emojis ocasionalmente.
        Mantenha respostas concisas e diretas.\`;

      // Adicionar contexto espec√≠fico baseado na inten√ß√£o
      systemPrompt += this.getIntentSpecificContext(intentResult.intent);

      // Adicionar contexto de personaliza√ß√£o
      if (userName) {
        systemPrompt += \`\\n\\nO nome do usu√°rio √© \${userName}. Use o nome ocasionalmente para personalizar as respostas.\`;
      }

      // Adicionar contexto de a√ß√µes pendentes
      if (pendingAction) {
        systemPrompt += \`\\n\\nO usu√°rio tem uma a√ß√£o pendente: \${pendingAction}. Ofere√ßa para continuar se relevante.\`;
      }

      // Adicionar contexto de retorno
      if (isUserReturn) {
        systemPrompt += \`\\n\\nEste usu√°rio j√° conversou antes. Seja acolhedor no retorno.\`;
      }

      // Adicionar contexto de sauda√ß√£o repetida
      if (isRepeatedGreeting) {
        systemPrompt += \`\\n\\nO usu√°rio j√° cumprimentou antes nesta conversa. Responda de forma natural sem se reapresentar.\`;
      }

      // Construir mensagens para o OpenAI
      const messages = [
        { role: "system", content: systemPrompt }
      ];

      // Adicionar hist√≥rico de conversa
      if (conversationMemory.recentMessages) {
        conversationMemory.recentMessages.forEach(msg => {
          messages.push({ role: "user", content: msg.user });
          messages.push({ role: "assistant", content: msg.assistant });
        });
      }

      // Adicionar mensagem atual
      messages.push({ role: "user", content: message });

      const completion = await openai.chat.completions.create({
        model: "gpt-4o",
        messages: messages,
        max_tokens: this.maxTokens,
        temperature: this.temperature
      });

      return completion.choices[0].message.content.trim();

    } catch (error) {
      console.error('‚ùå [EnhancedAI] Erro na gera√ß√£o de resposta:', error);
      return 'Desculpe, estou com dificuldades t√©cnicas. Tente novamente em alguns instantes.';
    }
  }

  getIntentSpecificContext(intent) {
    const contexts = {
      GREETING: '\\n\\nPara sauda√ß√µes, seja caloroso e pergunte como pode ajudar.',
      APPOINTMENT_REQUEST: '\\n\\nPara agendamentos, colete informa√ß√µes b√°sicas e oriente a confirmar por telefone.',
      CLINIC_INFO: '\\n\\nForne√ßa informa√ß√µes gerais da cl√≠nica de forma clara e √∫til.',
      DOCTOR_INFO: '\\n\\nForne√ßa informa√ß√µes sobre os m√©dicos dispon√≠veis.',
      SCHEDULE_INFO: '\\n\\nInforme os hor√°rios de funcionamento claramente.',
      PRICE_INFO: '\\n\\nPara pre√ßos, oriente a consultar diretamente a cl√≠nica.',
      LOCATION_INFO: '\\n\\nForne√ßa informa√ß√µes de localiza√ß√£o e como chegar.',
      ABOUT_BOT: '\\n\\nExplique suas capacidades como assistente virtual da cl√≠nica.',
      HELP: '\\n\\nOfere√ßa ajuda espec√≠fica e liste op√ß√µes dispon√≠veis.',
      CONTINUE_ACTION: '\\n\\nAjude a continuar a a√ß√£o que estava em andamento.',
      GOODBYE: '\\n\\nDespe√ßa-se de forma cordial e deixe a porta aberta para retorno.'
    };

    return contexts[intent] || '';
  }

  extractUserName(message, conversationMemory) {
    if (conversationMemory.userName) return conversationMemory.userName;

    const namePatterns = [
      /meu nome √© (\\w+)/i,
      /me chamo (\\w+)/i,
      /sou o (\\w+)/i,
      /sou a (\\w+)/i,
      /eu sou (\\w+)/i
    ];

    for (const pattern of namePatterns) {
      const match = message.match(pattern);
      if (match) {
        return match[1];
      }
    }

    return null;
  }

  isRepeatedGreeting(message, conversationMemory) {
    const greetingPatterns = /^(ol√°|oi|ola|bom dia|boa tarde|boa noite|hey|e a√≠)/i;
    
    if (!greetingPatterns.test(message)) return false;
    
    if (!conversationMemory.recentMessages) return false;
    
    return conversationMemory.recentMessages.some(msg => 
      greetingPatterns.test(msg.user)
    );
  }

  detectPendingAction(conversationMemory) {
    if (!conversationMemory.recentMessages) return null;

    const actionPatterns = {
      'agendamento': /agend|consulta|marcar/i,
      'informa√ß√µes': /informa√ß√£o|info|saber sobre/i,
      'pre√ßos': /pre√ßo|valor|custo|quanto/i,
      'hor√°rios': /hor√°rio|funcionamento|aberto/i,
      'localiza√ß√£o': /onde|endere√ßo|localiza√ß√£o|como chegar/i
    };

    for (const [action, pattern] of Object.entries(actionPatterns)) {
      const hasAction = conversationMemory.recentMessages.some(msg => 
        pattern.test(msg.user) && !msg.assistant.includes('telefone') && !msg.assistant.includes('diretamente')
      );
      
      if (hasAction) return action;
    }

    return null;
  }

  isUserReturn(conversationMemory) {
    if (!conversationMemory.recentMessages) return false;
    return conversationMemory.recentMessages.length > 3;
  }

  async loadConversationMemory(phoneNumber, agentId) {
    try {
      const { data, error } = await supabase
        .from('conversation_memory')
        .select('*')
        .eq('phone_number', phoneNumber)
        .eq('agent_id', agentId)
        .order('created_at', { ascending: false })
        .limit(this.maxHistoryTurns);

      if (error) throw error;

      const recentMessages = data.map(record => ({
        user: record.user_message,
        assistant: record.bot_response,
        timestamp: record.created_at
      })).reverse();

      const userName = data.find(record => record.user_name)?.user_name || null;

      return {
        recentMessages,
        userName,
        totalMessages: data.length
      };

    } catch (error) {
      console.error('‚ùå [EnhancedAI] Erro ao carregar mem√≥ria:', error);
      return { recentMessages: [], userName: null, totalMessages: 0 };
    }
  }

  async saveConversationMemory(phoneNumber, agentId, interaction) {
    try {
      const { error } = await supabase
        .from('conversation_memory')
        .insert({
          phone_number: phoneNumber,
          agent_id: agentId,
          user_message: interaction.userMessage,
          bot_response: interaction.botResponse,
          intent: interaction.intent,
          confidence: interaction.confidence,
          user_name: interaction.userName,
          pending_action: interaction.pendingAction,
          is_user_return: interaction.isUserReturn,
          created_at: interaction.timestamp
        });

      if (error) throw error;

      console.log('üíæ [EnhancedAI] Intera√ß√£o salva na mem√≥ria', { phoneNumber, agentId });

    } catch (error) {
      console.error('‚ùå [EnhancedAI] Erro ao salvar mem√≥ria:', error);
    }
  }
}

// Fun√ß√£o de compatibilidade com o sistema atual
async function processMessage(params) {
  const enhancedAI = new EnhancedAIService();
  return await enhancedAI.processMessage(
    params.message,
    params.phoneNumber,
    params.agentId,
    params.context
  );
}

module.exports = {
  EnhancedAIService,
  processMessage
};
`;

    // Salvar o EnhancedAIService
    const fs = require('fs');
    fs.writeFileSync('/tmp/enhancedAIService.js', enhancedAIServiceCode);
    console.log('‚úÖ EnhancedAIService criado em /tmp/enhancedAIService.js');

    // 5. CRIAR SCRIPT DE TESTE
    console.log('\n5Ô∏è‚É£ Criando script de teste...');
    
    const testScript = `
const { EnhancedAIService } = require('./enhancedAIService');

async function testEnhancedAI() {
  console.log('üß™ TESTANDO ENHANCED AI SERVICE');
  console.log('================================');
  
  const ai = new EnhancedAIService();
  const testPhoneNumber = '554730915628';
  const testAgentId = 'cardioprime';
  
  // Teste 1: Primeira sauda√ß√£o
  console.log('\\nüìù Teste 1: Primeira sauda√ß√£o');
  const test1 = await ai.processMessage(
    'Ol√°!',
    testPhoneNumber,
    testAgentId,
    {
      systemPrompt: 'Voc√™ √© o Dr. Carlos, assistente virtual da CardioPrime.',
      enableRAG: true,
      enableMemory: true,
      enablePersonalization: true
    }
  );
  console.log('Resposta:', test1.response);
  console.log('Inten√ß√£o:', test1.intent);
  console.log('Confian√ßa:', test1.confidence);
  console.log('‚úÖ Teste 1 conclu√≠do\\n');
  
  // Teste 2: Sauda√ß√£o repetida
  console.log('üìù Teste 2: Sauda√ß√£o repetida');
  const test2 = await ai.processMessage(
    'Ol√°!',
    testPhoneNumber,
    testAgentId,
    {
      systemPrompt: 'Voc√™ √© o Dr. Carlos, assistente virtual da CardioPrime.',
      enableRAG: true,
      enableMemory: true,
      enablePersonalization: true
    }
  );
  console.log('Resposta:', test2.response);
  console.log('√â sauda√ß√£o repetida:', test2.metadata.isRepeatedGreeting);
  console.log('‚úÖ Teste 2 conclu√≠do\\n');
  
  // Teste 3: Apresenta√ß√£o com nome
  console.log('üìù Teste 3: Apresenta√ß√£o com nome');
  const test3 = await ai.processMessage(
    'Meu nome √© Jo√£o',
    testPhoneNumber,
    testAgentId,
    {
      systemPrompt: 'Voc√™ √© o Dr. Carlos, assistente virtual da CardioPrime.',
      enableRAG: true,
      enableMemory: true,
      enablePersonalization: true
    }
  );
  console.log('Resposta:', test3.response);
  console.log('Nome extra√≠do:', test3.metadata.userName);
  console.log('‚úÖ Teste 3 conclu√≠do\\n');
  
  // Teste 4: Pergunta sobre capacidades
  console.log('üìù Teste 4: Pergunta sobre capacidades');
  const test4 = await ai.processMessage(
    'Para que voc√™ serve? Quais s√£o suas capacidades?',
    testPhoneNumber,
    testAgentId,
    {
      systemPrompt: 'Voc√™ √© o Dr. Carlos, assistente virtual da CardioPrime.',
      enableRAG: true,
      enableMemory: true,
      enablePersonalization: true
    }
  );
  console.log('Resposta:', test4.response);
  console.log('Inten√ß√£o:', test4.intent);
  console.log('‚úÖ Teste 4 conclu√≠do\\n');
  
  // Teste 5: Solicita√ß√£o de agendamento
  console.log('üìù Teste 5: Solicita√ß√£o de agendamento');
  const test5 = await ai.processMessage(
    'Gostaria de agendar uma consulta',
    testPhoneNumber,
    testAgentId,
    {
      systemPrompt: 'Voc√™ √© o Dr. Carlos, assistente virtual da CardioPrime.',
      enableRAG: true,
      enableMemory: true,
      enablePersonalization: true
    }
  );
  console.log('Resposta:', test5.response);
  console.log('Inten√ß√£o:', test5.intent);
  console.log('Usa nome do usu√°rio:', test5.response.includes('Jo√£o'));
  console.log('‚úÖ Teste 5 conclu√≠do\\n');
  
  console.log('üéâ Todos os testes conclu√≠dos!');
}

testEnhancedAI().catch(console.error);
`;

    fs.writeFileSync('/tmp/test-enhanced-ai.js', testScript);
    console.log('‚úÖ Script de teste criado em /tmp/test-enhanced-ai.js');

    console.log('\nüéØ IMPLEMENTA√á√ÉO CONCLU√çDA!');
    console.log('üìã RESUMO:');
    console.log('   ‚úÖ EnhancedAIService criado');
    console.log('   ‚úÖ Script de teste preparado');
    console.log('   ‚úÖ Sistema pronto para otimiza√ß√£o');
    console.log('   ‚úÖ Pr√≥ximo passo: Integrar no webhook');

  } catch (error) {
    console.error('‚ùå Erro cr√≠tico:', error);
  }
}

implementManusImprovements(); 