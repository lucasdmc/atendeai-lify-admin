/**
 * TESTE ESPEC√çFICO DO FLUXO DE AGENDAMENTO
 * 
 * Este script testa especificamente o fluxo de agendamento:
 * 1. Detec√ß√£o de inten√ß√£o
 * 2. Sele√ß√£o de servi√ßo
 * 3. Sele√ß√£o de data/hor√°rio
 * 4. Confirma√ß√£o
 * 5. Cria√ß√£o do agendamento
 */

import { LLMOrchestratorService, AppointmentFlowManager, ClinicContextManager } from './services/core/index.js';
import { createClient } from '@supabase/supabase-js';

// Configura√ß√£o do Supabase
const supabase = createClient(
  process.env.VITE_SUPABASE_URL || 'https://niakqdolcdwxtrkbqmdi.supabase.co',
  process.env.SUPABASE_SERVICE_ROLE_KEY || 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6Im5pYWtxZG9sY2JxbWRpIiwicm9sZSI6InNlcnZpY2Vfcm9sZSIsImlhdCI6MTc1MDE4MjU1OSwiZXhwIjoyMDY1NzU4NTU5fQ.SY8A3ReAs_D7SFBp99PpSe8rpm1hbWMv4b2q-c_VS5M'
);

class AppointmentFlowSpecificTest {
  constructor() {
    this.testResults = [];
    this.errors = [];
    this.currentFlowState = null;
    this.clinicContext = null;
    this.testPhoneNumber = '+5547999999999';
  }

  /**
   * Executa teste espec√≠fico do fluxo de agendamento
   */
  async runAppointmentFlowTest() {
    console.log('üöÄ INICIANDO TESTE ESPEC√çFICO DO FLUXO DE AGENDAMENTO');
    console.log('=' .repeat(80));
    
    try {
      // Preparar ambiente
      await this.prepareTestEnvironment();
      
      // Teste 1: Detec√ß√£o de inten√ß√£o de agendamento
      await this.testAppointmentIntentDetection();
      
      // Teste 2: Inicializa√ß√£o do fluxo
      await this.testFlowInitialization();
      
      // Teste 3: Sele√ß√£o de servi√ßo
      await this.testServiceSelection();
      
      // Teste 4: Sele√ß√£o de data e hor√°rio
      await this.testDateTimeSelection();
      
      // Teste 5: Confirma√ß√£o do agendamento
      await this.testAppointmentConfirmation();
      
      // Teste 6: Finaliza√ß√£o do agendamento
      await this.testAppointmentFinalization();
      
      // Relat√≥rio final
      this.generateFlowTestReport();
      
    } catch (error) {
      console.error('üí• ERRO CR√çTICO NO TESTE DO FLUXO:', error);
      this.errors.push({
        test: 'FLUXO_PRINCIPAL',
        error: error.message,
        stack: error.stack
      });
      this.generateFlowTestReport();
    }
  }

  /**
   * Prepara ambiente de teste
   */
  async prepareTestEnvironment() {
    console.log('\nüîß PREPARANDO AMBIENTE DE TESTE');
    console.log('-'.repeat(50));
    
    try {
      // Buscar cl√≠nica dispon√≠vel
      const { data: clinics, error } = await supabase
        .from('clinics')
        .select('*')
        .eq('has_contextualization', true)
        .limit(1);
      
      if (error || !clinics || clinics.length === 0) {
        throw new Error('Nenhuma cl√≠nica dispon√≠vel para teste');
      }
      
      const clinic = clinics[0];
      console.log(`üè• Usando cl√≠nica para teste: ${clinic.name}`);
      
      // Obter contexto da cl√≠nica
      this.clinicContext = await ClinicContextManager.getClinicContext(clinic.name);
      
      if (!this.clinicContext) {
        throw new Error('N√£o foi poss√≠vel obter contexto da cl√≠nica');
      }
      
      console.log('‚úÖ Contexto da cl√≠nica obtido com sucesso');
      
      // Inicializar servi√ßos
      await LLMOrchestratorService.initializeAppointmentFlow();
      console.log('‚úÖ Servi√ßos inicializados');
      
    } catch (error) {
      console.error(`‚ùå ${error.message}`);
      throw error;
    }
  }

  /**
   * Teste 1: Detec√ß√£o de inten√ß√£o de agendamento
   */
  async testAppointmentIntentDetection() {
    console.log('\nüîç TESTE 1: DETEC√á√ÉO DE INTEN√á√ÉO DE AGENDAMENTO');
    console.log('-'.repeat(50));
    
    try {
      const testMessages = [
        'Gostaria de agendar uma consulta',
        'Quero marcar um hor√°rio',
        'Preciso agendar um exame',
        'Como fa√ßo para marcar uma consulta?'
      ];
      
      for (const message of testMessages) {
        console.log(`üì± Testando mensagem: "${message}"`);
        
        const intent = await LLMOrchestratorService.detectIntent(message);
        
        if (!intent || !intent.name) {
          throw new Error(`Detec√ß√£o de inten√ß√£o falhou para: "${message}"`);
        }
        
        console.log(`   ‚úÖ Inten√ß√£o: ${intent.name} (confian√ßa: ${intent.confidence})`);
        
        const isAppointmentIntent = LLMOrchestratorService.isAppointmentIntent(intent);
        
        if (!isAppointmentIntent) {
          this.warnings.push({
            test: 'INTENT_DETECTION',
            warning: `Mensagem "${message}" n√£o foi reconhecida como inten√ß√£o de agendamento`
          });
        }
      }
      
      this.testResults.push({ test: 'INTENT_DETECTION', status: 'PASS' });
      console.log('‚úÖ Detec√ß√£o de inten√ß√£o funcionando');
      
    } catch (error) {
      console.error(`‚ùå ${error.message}`);
      this.errors.push({ test: 'INTENT_DETECTION', error: error.message });
    }
  }

  /**
   * Teste 2: Inicializa√ß√£o do fluxo
   */
  async testFlowInitialization() {
    console.log('\nüöÄ TESTE 2: INICIALIZA√á√ÉO DO FLUXO');
    console.log('-'.repeat(50));
    
    try {
      // Criar inst√¢ncia do AppointmentFlowManager
      const appointmentFlow = new AppointmentFlowManager();
      await appointmentFlow.initialize();
      
      // Criar estado inicial do fluxo
      this.currentFlowState = appointmentFlow.createNewFlowState(this.clinicContext);
      
      if (!this.currentFlowState || !this.currentFlowState.step) {
        throw new Error('Estado inicial do fluxo n√£o foi criado corretamente');
      }
      
      console.log(`‚úÖ Estado inicial criado: ${this.currentFlowState.step}`);
      
      // Verificar se o estado est√° correto
      if (this.currentFlowState.step !== 'initial') {
        throw new Error(`Estado inicial incorreto. Esperado: 'initial', Obtido: '${this.currentFlowState.step}'`);
      }
      
      // Verificar se os dados est√£o inicializados
      if (!this.currentFlowState.data || !this.currentFlowState.data.clinicId) {
        throw new Error('Dados do fluxo n√£o foram inicializados corretamente');
      }
      
      console.log('‚úÖ Dados do fluxo inicializados corretamente');
      
      this.testResults.push({ test: 'FLOW_INITIALIZATION', status: 'PASS' });
      
    } catch (error) {
      console.error(`‚ùå ${error.message}`);
      this.errors.push({ test: 'FLOW_INITIALIZATION', error: error.message });
    }
  }

  /**
   * Teste 3: Sele√ß√£o de servi√ßo
   */
  async testServiceSelection() {
    console.log('\nüè• TESTE 3: SELE√á√ÉO DE SERVI√áO');
    console.log('-'.repeat(50));
    
    try {
      const appointmentFlow = new AppointmentFlowManager();
      
      // Simular in√≠cio da cria√ß√£o de agendamento
      const memory = {
        userProfile: { name: 'Jo√£o Teste' },
        history: []
      };
      
      const intent = { name: 'APPOINTMENT_CREATE', confidence: 0.9 };
      
      const result = await appointmentFlow.handleAppointmentIntent(
        this.testPhoneNumber,
        'Gostaria de agendar uma consulta',
        intent,
        this.clinicContext,
        memory
      );
      
      if (!result || !result.response) {
        throw new Error('Resposta do fluxo de agendamento n√£o foi gerada');
      }
      
      console.log('‚úÖ Resposta do fluxo gerada com sucesso');
      console.log(`üìù Resposta: ${result.response.substring(0, 100)}...`);
      
      // Verificar se o fluxo avan√ßou para sele√ß√£o de servi√ßo
      if (result.metadata?.flowStep !== 'service_selection') {
        throw new Error(`Fluxo n√£o avan√ßou para sele√ß√£o de servi√ßo. Estado atual: ${result.metadata?.flowStep}`);
      }
      
      console.log('‚úÖ Fluxo avan√ßou para sele√ß√£o de servi√ßo');
      
      // Verificar se h√° servi√ßos dispon√≠veis
      if (!result.metadata?.availableServices || result.metadata.availableServices === 0) {
        this.warnings.push({
          test: 'SERVICE_SELECTION',
          warning: 'Nenhum servi√ßo dispon√≠vel para agendamento'
        });
      } else {
        console.log(`‚úÖ ${result.metadata.availableServices} servi√ßo(s) dispon√≠vel(is)`);
      }
      
      this.testResults.push({ test: 'SERVICE_SELECTION', status: 'PASS' });
      
    } catch (error) {
      console.error(`‚ùå ${error.message}`);
      this.errors.push({ test: 'SERVICE_SELECTION', error: error.message });
    }
  }

  /**
   * Teste 4: Sele√ß√£o de data e hor√°rio
   */
  async testDateTimeSelection() {
    console.log('\nüìÖ TESTE 4: SELE√á√ÉO DE DATA E HOR√ÅRIO');
    console.log('-'.repeat(50));
    
    try {
      const appointmentFlow = new AppointmentFlowManager();
      
      // Simular sele√ß√£o de servi√ßo
      const flowState = {
        step: 'service_selection',
        data: {
          selectedService: { name: 'Consulta M√©dica', duration: 30 },
          clinicId: this.clinicContext.id
        }
      };
      
      // Simular mensagem de sele√ß√£o de servi√ßo
      const result = await appointmentFlow.handleAppointmentCreation(
        this.testPhoneNumber,
        'Consulta m√©dica',
        this.clinicContext,
        { userProfile: { name: 'Jo√£o Teste' } },
        flowState
      );
      
      if (!result || !result.response) {
        throw new Error('Resposta para sele√ß√£o de data/hor√°rio n√£o foi gerada');
      }
      
      console.log('‚úÖ Resposta para sele√ß√£o de data/hor√°rio gerada');
      console.log(`üìù Resposta: ${result.response.substring(0, 100)}...`);
      
      // Verificar se o fluxo avan√ßou para sele√ß√£o de data/hor√°rio
      if (result.metadata?.flowStep !== 'date_time_selection') {
        throw new Error(`Fluxo n√£o avan√ßou para sele√ß√£o de data/hor√°rio. Estado atual: ${result.metadata?.flowStep}`);
      }
      
      console.log('‚úÖ Fluxo avan√ßou para sele√ß√£o de data/hor√°rio');
      
      // Verificar se h√° hor√°rios dispon√≠veis
      if (!result.metadata?.availableSlots || result.metadata.availableSlots === 0) {
        this.warnings.push({
          test: 'DATETIME_SELECTION',
          warning: 'Nenhum hor√°rio dispon√≠vel para agendamento'
        });
      } else {
        console.log(`‚úÖ ${result.metadata.availableSlots} hor√°rio(s) dispon√≠vel(is)`);
      }
      
      this.testResults.push({ test: 'DATETIME_SELECTION', status: 'PASS' });
      
    } catch (error) {
      console.error(`‚ùå ${error.message}`);
      this.errors.push({ test: 'DATETIME_SELECTION', error: error.message });
    }
  }

  /**
   * Teste 5: Confirma√ß√£o do agendamento
   */
  async testAppointmentConfirmation() {
    console.log('\n‚úÖ TESTE 5: CONFIRMA√á√ÉO DO AGENDAMENTO');
    console.log('-'.repeat(50));
    
    try {
      const appointmentFlow = new AppointmentFlowManager();
      
      // Simular sele√ß√£o de data/hor√°rio
      const flowState = {
        step: 'date_time_selection',
        data: {
          selectedService: { name: 'Consulta M√©dica', duration: 30 },
          selectedSlot: {
            date: new Date(Date.now() + 24 * 60 * 60 * 1000), // Amanh√£
            startTime: '09:00',
            endTime: '09:30'
          },
          clinicId: this.clinicContext.id
        }
      };
      
      // Simular confirma√ß√£o
      const result = await appointmentFlow.handleAppointmentCreation(
        this.testPhoneNumber,
        'Sim, confirmo',
        this.clinicContext,
        { userProfile: { name: 'Jo√£o Teste' } },
        flowState
      );
      
      if (!result || !result.response) {
        throw new Error('Resposta de confirma√ß√£o n√£o foi gerada');
      }
      
      console.log('‚úÖ Resposta de confirma√ß√£o gerada');
      console.log(`üìù Resposta: ${result.response.substring(0, 100)}...`);
      
      // Verificar se o fluxo avan√ßou para confirma√ß√£o
      if (result.metadata?.flowStep !== 'confirmation') {
        throw new Error(`Fluxo n√£o avan√ßou para confirma√ß√£o. Estado atual: ${result.metadata?.flowStep}`);
      }
      
      console.log('‚úÖ Fluxo avan√ßou para confirma√ß√£o');
      
      this.testResults.push({ test: 'APPOINTMENT_CONFIRMATION', status: 'PASS' });
      
    } catch (error) {
      console.error(`‚ùå ${error.message}`);
      this.errors.push({ test: 'APPOINTMENT_CONFIRMATION', error: error.message });
    }
  }

  /**
   * Teste 6: Finaliza√ß√£o do agendamento
   */
  async testAppointmentFinalization() {
    console.log('\nüéØ TESTE 6: FINALIZA√á√ÉO DO AGENDAMENTO');
    console.log('-'.repeat(50));
    
    try {
      const appointmentFlow = new AppointmentFlowManager();
      
      // Simular confirma√ß√£o final
      const flowState = {
        step: 'confirmation',
        data: {
          selectedService: { name: 'Consulta M√©dica', duration: 30 },
          selectedSlot: {
            date: new Date(Date.now() + 24 * 60 * 60 * 1000), // Amanh√£
            startTime: '09:00',
            endTime: '09:30'
          },
          clinicId: this.clinicContext.id
        }
      };
      
      // Simular confirma√ß√£o final
      const result = await appointmentFlow.handleAppointmentCreation(
        this.testPhoneNumber,
        '1', // Confirmar
        this.clinicContext,
        { userProfile: { name: 'Jo√£o Teste' } },
        flowState
      );
      
      if (!result || !result.response) {
        throw new Error('Resposta de finaliza√ß√£o n√£o foi gerada');
      }
      
      console.log('‚úÖ Resposta de finaliza√ß√£o gerada');
      console.log(`üìù Resposta: ${result.response.substring(0, 100)}...`);
      
      // Verificar se o agendamento foi finalizado
      if (result.metadata?.flowStep !== 'completed') {
        console.log('‚ö†Ô∏è Fluxo n√£o foi marcado como completo (pode ser esperado em ambiente de teste)');
      } else {
        console.log('‚úÖ Fluxo marcado como completo');
      }
      
      this.testResults.push({ test: 'APPOINTMENT_FINALIZATION', status: 'PASS' });
      
    } catch (error) {
      console.error(`‚ùå ${error.message}`);
      this.errors.push({ test: 'APPOINTMENT_FINALIZATION', error: error.message });
    }
  }

  /**
   * Gera relat√≥rio final do teste de fluxo
   */
  generateFlowTestReport() {
    console.log('\n' + '='.repeat(80));
    console.log('üìä RELAT√ìRIO FINAL DO TESTE DE FLUXO DE AGENDAMENTO');
    console.log('='.repeat(80));
    
    const totalTests = this.testResults.length;
    const passedTests = this.testResults.filter(r => r.status === 'PASS').length;
    const failedTests = this.errors.length;
    const warningsCount = this.warnings?.length || 0;
    
    console.log(`\nüìà RESUMO DO FLUXO:`);
    console.log(`   ‚úÖ Testes aprovados: ${passedTests}/${totalTests}`);
    console.log(`   ‚ùå Testes falharam: ${failedTests}`);
    console.log(`   ‚ö†Ô∏è  Avisos: ${warningsCount}`);
    
    if (this.errors.length > 0) {
      console.log(`\n‚ùå ERROS NO FLUXO:`);
      this.errors.forEach((error, index) => {
        console.log(`   ${index + 1}. [${error.test}] ${error.error}`);
      });
    }
    
    if (this.warnings && this.warnings.length > 0) {
      console.log(`\n‚ö†Ô∏è  AVISOS NO FLUXO:`);
      this.warnings.forEach((warning, index) => {
        console.log(`   ${index + 1}. [${warning.test}] ${warning.warning}`);
      });
    }
    
    if (failedTests === 0) {
      console.log(`\nüéâ FLUXO DE AGENDAMENTO APROVADO! Sistema funcionando corretamente.`);
    } else {
      console.log(`\nüö® FLUXO DE AGENDAMENTO COM PROBLEMAS! Corrija os erros antes de prosseguir.`);
      process.exit(1);
    }
  }
}

// Executar teste se o arquivo for executado diretamente
if (import.meta.url === `file://${process.argv[1]}`) {
  const tester = new AppointmentFlowSpecificTest();
  tester.runAppointmentFlowTest().catch(error => {
    console.error('üí• ERRO FATAL NO TESTE DE FLUXO:', error);
    process.exit(1);
  });
}

export default AppointmentFlowSpecificTest;
