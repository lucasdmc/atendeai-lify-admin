/**
 * TESTE PARA VALIDAR CORRE√á√ÉO DO FLUXO DE AGENDAMENTO
 */

import dotenv from 'dotenv';

// Carregar vari√°veis de ambiente
dotenv.config();

console.log('üîß TESTE PARA VALIDAR CORRE√á√ÉO DO FLUXO DE AGENDAMENTO');
console.log('=' .repeat(80));

class AppointmentFlowFixTest {
  constructor() {
    this.testResults = [];
    this.errors = [];
  }

  /**
   * Executa teste do fluxo corrigido
   */
  async runFlowFixTest() {
    try {
      // Teste 1: Verificar fluxo inicial
      await this.testInitialFlow();
      
      // Teste 2: Verificar sele√ß√£o de servi√ßo
      await this.testServiceSelection();
      
      // Teste 3: Verificar continua√ß√£o do fluxo
      await this.testFlowContinuation();
      
      // Relat√≥rio final
      this.generateFlowFixReport();
      
    } catch (error) {
      console.error('üí• ERRO NO TESTE DO FLUXO:', error);
      this.errors.push({
        test: 'EXECU√á√ÉO_PRINCIPAL',
        error: error.message
      });
      this.generateFlowFixReport();
    }
  }

  /**
   * Teste 1: Verificar fluxo inicial
   */
  async testInitialFlow() {
    console.log('\nüîç TESTE 1: FLUXO INICIAL');
    console.log('-'.repeat(50));
    
    try {
      // Importar servi√ßos
      const { AppointmentFlowManager, ClinicContextManager } = await import('./services/core/index.js');
      
      // Buscar cl√≠nica dispon√≠vel
      const { createClient } = await import('@supabase/supabase-js');
      const supabase = createClient(
        process.env.VITE_SUPABASE_URL,
        process.env.SUPABASE_SERVICE_ROLE_KEY
      );
      
      const { data: clinics } = await supabase
        .from('clinics')
        .select('*')
        .eq('has_contextualization', true)
        .limit(1);
      
      const clinic = clinics[0];
      console.log(`üè• Testando com cl√≠nica: ${clinic.name}`);
      
      // Obter contexto da cl√≠nica
      const clinicContext = await ClinicContextManager.getClinicContext(clinic.name);
      
      // Criar inst√¢ncia do AppointmentFlowManager
      const appointmentFlow = new AppointmentFlowManager();
      await appointmentFlow.initialize();
      
      // Simular mensagem inicial
      const testMessage = 'Gostaria de realizar um agendamento';
      const testPhoneNumber = '+5547999999999';
      const memory = { userProfile: { name: 'Jo√£o Teste' } };
      const intent = { name: 'APPOINTMENT_CREATE', confidence: 0.9 };
      
      console.log(`üì± Simulando mensagem inicial: "${testMessage}"`);
      
      // Testar fluxo inicial
      const result = await appointmentFlow.handleAppointmentIntent(
        testPhoneNumber,
        testMessage,
        intent,
        clinicContext,
        memory
      );
      
      if (!result || !result.response) {
        throw new Error('Fluxo inicial n√£o retornou resposta');
      }
      
      console.log('‚úÖ Fluxo inicial executado com sucesso');
      console.log(`üìù Resposta gerada: ${result.response.substring(0, 100)}...`);
      
      // Verificar se o fluxo avan√ßou para sele√ß√£o de servi√ßo
      if (result.metadata?.flowStep === 'service_selection') {
        console.log('‚úÖ Fluxo avan√ßou para sele√ß√£o de servi√ßo');
      } else {
        console.log('‚ö†Ô∏è Fluxo n√£o avan√ßou corretamente');
        this.errors.push({
          test: 'INITIAL_FLOW',
          error: 'Fluxo n√£o avan√ßou para sele√ß√£o de servi√ßo'
        });
      }
      
      this.testResults.push({ test: 'INITIAL_FLOW', status: 'PASS' });
      
    } catch (error) {
      console.error(`‚ùå ${error.message}`);
      this.errors.push({ test: 'INITIAL_FLOW', error: error.message });
    }
  }

  /**
   * Teste 2: Verificar sele√ß√£o de servi√ßo
   */
  async testServiceSelection() {
    console.log('\nüîç TESTE 2: SELE√á√ÉO DE SERVI√áO');
    console.log('-'.repeat(50));
    
    try {
      // Importar servi√ßos
      const { AppointmentFlowManager, ClinicContextManager } = await import('./services/core/index.js');
      
      // Buscar cl√≠nica dispon√≠vel
      const { createClient } = await import('@supabase/supabase-js');
      const supabase = createClient(
        process.env.VITE_SUPABASE_URL,
        process.env.SUPABASE_SERVICE_ROLE_KEY
      );
      
      const { data: clinics } = await supabase
        .from('clinics')
        .select('*')
        .eq('has_contextualization', true)
        .limit(1);
      
      const clinic = clinics[0];
      console.log(`üè• Testando sele√ß√£o de servi√ßo com cl√≠nica: ${clinic.name}`);
      
      // Obter contexto da cl√≠nica
      const clinicContext = await ClinicContextManager.getClinicContext(clinic.name);
      
      // Criar inst√¢ncia do AppointmentFlowManager
      const appointmentFlow = new AppointmentFlowManager();
      await appointmentFlow.initialize();
      
      // Simular fluxo inicial
      const testPhoneNumber = '+5547999999999';
      const memory = { userProfile: { name: 'Jo√£o Teste' } };
      const intent = { name: 'APPOINTMENT_CREATE', confidence: 0.9 };
      
      const initialResult = await appointmentFlow.handleAppointmentIntent(
        testPhoneNumber,
        'Gostaria de realizar um agendamento',
        intent,
        clinicContext,
        memory
      );
      
      if (!initialResult || initialResult.metadata?.flowStep !== 'service_selection') {
        throw new Error('Fluxo inicial n√£o configurado corretamente');
      }
      
      console.log('‚úÖ Fluxo inicial configurado, testando sele√ß√£o de servi√ßo...');
      
      // Simular sele√ß√£o de servi√ßo "1"
      const serviceSelectionResult = await appointmentFlow.handleAppointmentIntent(
        testPhoneNumber,
        '1',
        { name: 'APPOINTMENT_CONTINUE', confidence: 0.9 },
        clinicContext,
        memory
      );
      
      if (!serviceSelectionResult || !serviceSelectionResult.response) {
        throw new Error('Sele√ß√£o de servi√ßo n√£o retornou resposta');
      }
      
      console.log('‚úÖ Sele√ß√£o de servi√ßo processada com sucesso');
      console.log(`üìù Resposta: ${serviceSelectionResult.response.substring(0, 100)}...`);
      
      // Verificar se o fluxo avan√ßou para sele√ß√£o de data/hora
      if (serviceSelectionResult.metadata?.flowStep === 'date_time_selection') {
        console.log('‚úÖ Fluxo avan√ßou para sele√ß√£o de data/hora');
      } else {
        console.log('‚ö†Ô∏è Fluxo n√£o avan√ßou para sele√ß√£o de data/hora');
        this.errors.push({
          test: 'SERVICE_SELECTION',
          error: 'Fluxo n√£o avan√ßou para sele√ß√£o de data/hora'
        });
      }
      
      this.testResults.push({ test: 'SERVICE_SELECTION', status: 'PASS' });
      
    } catch (error) {
      console.error(`‚ùå ${error.message}`);
      this.errors.push({ test: 'SERVICE_SELECTION', error: error.message });
    }
  }

  /**
   * Teste 3: Verificar continua√ß√£o do fluxo
   */
  async testFlowContinuation() {
    console.log('\nüîç TESTE 3: CONTINUA√á√ÉO DO FLUXO');
    console.log('-'.repeat(50));
    
    try {
      // Importar servi√ßos
      const { AppointmentFlowManager, ClinicContextManager } = await import('./services/core/index.js');
      
      // Buscar cl√≠nica dispon√≠vel
      const { createClient } = await import('@supabase/supabase-js');
      const supabase = createClient(
        process.env.VITE_SUPABASE_URL,
        process.env.SUPABASE_SERVICE_ROLE_KEY
      );
      
      const { data: clinics } = await supabase
        .from('clinics')
        .select('*')
        .eq('has_contextualization', true)
        .limit(1);
      
      const clinic = clinics[0];
      console.log(`üè• Testando continua√ß√£o do fluxo com cl√≠nica: ${clinic.name}`);
      
      // Obter contexto da cl√≠nica
      const clinicContext = await ClinicContextManager.getClinicContext(clinic.name);
      
      // Criar inst√¢ncia do AppointmentFlowManager
      const appointmentFlow = new AppointmentFlowManager();
      await appointmentFlow.initialize();
      
      // Simular fluxo completo
      const testPhoneNumber = '+5547999999999';
      const memory = { userProfile: { name: 'Jo√£o Teste' } };
      
      // Passo 1: Inicializar
      await appointmentFlow.handleAppointmentIntent(
        testPhoneNumber,
        'Gostaria de realizar um agendamento',
        { name: 'APPOINTMENT_CREATE', confidence: 0.9 },
        clinicContext,
        memory
      );
      
      // Passo 2: Selecionar servi√ßo
      await appointmentFlow.handleAppointmentIntent(
        testPhoneNumber,
        '1',
        { name: 'APPOINTMENT_CONTINUE', confidence: 0.9 },
        clinicContext,
        memory
      );
      
      // Verificar se h√° fluxo ativo
      const hasActiveFlow = appointmentFlow.hasActiveFlow(testPhoneNumber);
      if (hasActiveFlow) {
        console.log('‚úÖ Fluxo ativo detectado');
        
        const flowState = appointmentFlow.getFlowState(testPhoneNumber);
        console.log(`üìã Estado atual do fluxo: ${flowState.step}`);
        
        if (flowState.step === 'date_time_selection') {
          console.log('‚úÖ Fluxo avan√ßou corretamente para sele√ß√£o de data/hora');
        } else {
          console.log('‚ö†Ô∏è Fluxo n√£o avan√ßou corretamente');
          this.errors.push({
            test: 'FLOW_CONTINUATION',
            error: `Fluxo n√£o avan√ßou corretamente. Estado atual: ${flowState.step}`
          });
        }
      } else {
        console.log('‚ùå Fluxo ativo n√£o detectado');
        this.errors.push({
          test: 'FLOW_CONTINUATION',
          error: 'Fluxo ativo n√£o foi detectado'
        });
      }
      
      this.testResults.push({ test: 'FLOW_CONTINUATION', status: 'PASS' });
      
    } catch (error) {
      console.error(`‚ùå ${error.message}`);
      this.errors.push({ test: 'FLOW_CONTINUATION', error: error.message });
    }
  }

  /**
   * Gera relat√≥rio final do teste do fluxo
   */
  generateFlowFixReport() {
    console.log('\n' + '='.repeat(80));
    console.log('üìä RELAT√ìRIO FINAL DO TESTE DO FLUXO');
    console.log('='.repeat(80));
    
    const totalTests = this.testResults.length;
    const passedTests = this.testResults.filter(r => r.status === 'PASS').length;
    const failedTests = this.errors.length;
    
    console.log(`\nüìà RESUMO DO FLUXO:`);
    console.log(`   ‚úÖ Testes aprovados: ${passedTests}/${totalTests}`);
    console.log(`   ‚ùå Testes falharam: ${failedTests}`);
    
    if (this.errors.length > 0) {
      console.log(`\n‚ùå PROBLEMAS IDENTIFICADOS:`);
      this.errors.forEach((error, index) => {
        console.log(`   ${index + 1}. [${error.test}] ${error.error}`);
      });
    }
    
    if (failedTests === 0) {
      console.log(`\nüéâ FLUXO DE AGENDAMENTO FUNCIONANDO PERFEITAMENTE!`);
      console.log(`\nüí° CORRE√á√ïES IMPLEMENTADAS:`);
      console.log(`   ‚úÖ Persist√™ncia de estado do fluxo`);
      console.log(`   ‚úÖ Continua√ß√£o autom√°tica do fluxo`);
      console.log(`   ‚úÖ Sele√ß√£o de servi√ßo funcionando`);
      console.log(`   ‚úÖ Avan√ßo correto entre etapas`);
      console.log(`   ‚úÖ Sistema de fluxo robusto`);
    } else {
      console.log(`\nüö® AINDA H√Å PROBLEMAS NO FLUXO! Corrija antes de prosseguir.`);
      process.exit(1);
    }
  }
}

// Executar teste
const tester = new AppointmentFlowFixTest();
tester.runFlowFixTest().catch(error => {
  console.error('üí• ERRO FATAL NO TESTE DO FLUXO:', error);
  process.exit(1);
});
